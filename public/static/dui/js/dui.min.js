(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define('dui', factory) :
  (global = global || self, global.dui = factory());
}(this, function () { 'use strict';

  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var slice = [].slice;

  var definedModules = {}; // 默认配置

  var config = {
    dir: getPath(),
    //dui所在目录
    base: '' //扩展模块地址

  }; // 默认配置

  Dui.defaluts = {
    // 内置模块配置
    plugins: {
      'jquery': 'plugins/jquery',
      // jquery
      'template': 'plugins/template',
      // 模板引擎
      'popup': 'plugins/popup',
      // 弹出层
      'element': 'plugins/element',
      // 基本元素
      'form': 'plugins/form',
      // 表单
      'table': 'plugins/table',
      // 表格
      'pagination': 'plugins/pagination',
      // 分页
      'tree': 'plugins/tree',
      // 树形插件
      'duiDate': 'plugins/duiDate',
      // 时间插件
      'upload': 'plugins/upload',
      //上传插件
      'iconPicker': 'plugins/iconPicker',
      //图标选择插件
      'pjax': 'plugins/pjax' //pjax插件

    }
    /**
     * 获取当前运行的js
     */

  };

  function getCurrent() {
    var jsPath = document.currentScript ? document.currentScript.src : function () {
      var js = document.scripts,
          last = js.length - 1,
          src;

      for (var i = last; i > 0; i--) {
        if (js[i].readyState === 'interactive') {
          src = js[i].src;
          break;
        }
      }

      return src || js[last].src;
    }();
    return jsPath;
  }
  /**
   * 判断是否是完整的地址
   * @param {String} url 网址
   */


  function isUrl(url) {
    return url.search(/^(http:\/\/|https:\/\/|\/\/)/) !== -1;
  }
  /**
   * 补充完整路径
   * @param {String} url 路径
   */


  function fixUrl(url) {
    return url.replace(/([^:])\/+/g, '$1/');
  }
  /**
   * 获取路径
   * @param {String} path 需要组合的路径
   * @param {Object} cfg 配置信息
   */


  function getUrl(path, cfg) {
    var url = cfg.base || window.location.href; //绝对网址

    if (isUrl(path)) {
      return fixUrl(path);
    }

    var rootUrl; //修复url

    if (rootUrl = url.match(/[^\/]*\/\/[^\/]*\//)) {
      //http://yanhaijing.com/abc
      url = url.slice(0, url.lastIndexOf('/') + 1);
      rootUrl = rootUrl[0];
    } else {
      //http://yanhaijing.com
      rootUrl = url = url + '/';
    } // /开头


    if (path.search(/^\//) !== -1) {
      return fixUrl(rootUrl + path);
    } // ../开头


    if (path.search(/^\.\.\//) !== -1) {
      while (path.search(/^\.\.\//) !== -1) {
        if (url.lastIndexOf('/', url.length - 2) !== -1) {
          path = path.slice(3);
          url = url.slice(0, url.lastIndexOf('/', url.length - 2) + 1);
        } else {
          throw new Error('lodjs geturl error, cannot find path in url');
        }
      }

      return fixUrl(url + path);
    } // ./


    path = path.search(/^\.\//) !== -1 ? path.slice(2) : path;
    return fixUrl(url + path);
  }
  /**
   * 修正完整的路径
   * @param {String} url 需要修正的路径
   * @param {String}} suffix 路径后缀名
   */


  function fixSuffix(url, suffix) {
    var reg = new RegExp('\\.' + suffix + '$', 'i');
    return url.search(reg) !== -1 ? url : url + '.' + suffix;
  }
  /**
   * 获取当前依赖的完整地址
   * @param {String} id 模块id
   * @param {Object} cfg 配置信息
   */


  function getDepUrl(id, cfg) {
    // 如果是内部地址
    if (Dui.defaluts.plugins[id]) {
      return fixSuffix(config.dir + Dui.defaluts.plugins[id], 'js');
    }

    return fixSuffix(getUrl(id, cfg), 'js');
  }
  /**
   * 根据模块id获取模块地址
   * @param {String} id 模块id
   */


  function getIdUrl(id, cfg) {
    //没有id的情况
    if (!id) {
      var temp = getCurrentScript().src; // 获取当前活动的id

      if (temp) {
        return temp;
      } else {
        throw new Error('在页面定义模块需要指定模块id');
      }
    } // 如果是内置模块则返回内置模块的url


    if (Dui.defaluts.plugins[id]) {
      return fixSuffix(config.dir + Dui.defaluts.plugins[id], 'js');
    } //id不能为相对路径,amd规定此处也不能带后缀，此处放宽限制。


    if (id.search(/^\./) !== -1) {
      throw new Error('lodjs define id' + id + 'must absolute');
    }

    return fixSuffix(getUrl(id, cfg), 'js');
  }
  /**
   * 获取目录地址
   * @param {String} src 获取目录地址把url转为path
   */


  function getPath(src) {
    return src ? src.substring(0, src.lastIndexOf('/') + 1) : getCurrent().substring(0, getCurrent().lastIndexOf('/') + 1);
  }
  /**
   * 判断变量是否是数组
   * @param {Object=} arr 任意数据
   */


  function isArray(arr) {
    return Array.isArray ? Array.isArray(arr) : getType(arr) === 'array';
  }
  /**
   * 用来判断的是否是对象数据
   * @param {Object} arr 任意变量
   */


  function isObject(arr) {
    return type(arr) === "object";
  }
  /**
   * 判断变量是否是方法
   * @param {Object=} arr 
   */


  function isFunction(arr) {
    return typeof arr === "function";
  }
  /**
   * 获取参数的类型
   * @param {Object} obj 
   */


  function type(x) {
    if (x === null) {
      return 'null';
    }

    var t = typeof x;

    if (t !== 'object') {
      return t;
    }

    var c = toString.call(x).slice(8, -1).toLowerCase();

    if (c !== 'object') {
      return c;
    }

    if (x.constructor == Object) {
      return c;
    }

    return 'unkonw';
  }
  /**
   * 判断传入的参数是否为window对象
   * @param {Object} obj 
   */


  function isWindow(obj) {
    return obj != null && obj == obj.window;
  }
  /**
   * 检查是否是纯对象
   * @param {Object} obj 
   */


  function isPlainObject(obj) {
    var key; // Must be an Object.
    // Because of IE, we also have to check the presence of the constructor property.
    // Make sure that DOM nodes and window objects don't pass through, as well

    if (!obj || type(obj) !== "object" || obj.nodeType || isWindow(obj)) {
      return false;
    }

    try {
      // Not own constructor property must be Object
      if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
        return false;
      }
    } catch (e) {
      // IE8,9 Will throw exceptions on certain host objects #9897
      return false;
    } // Support: IE<9
    // Handle iteration over inherited properties before own properties.


    {
      for (key in obj) {
        return hasOwn.call(obj, key);
      }
    } // Own properties are enumerated firstly, so to speed up,
    // if last one is own, then all properties are own.


    for (key in obj) {}

    return key === undefined || hasOwn.call(obj, key);
  }
  /**
   * 判断是否是Array
   * @param {Object} obj 
   */


  function isArrayLike(obj) {
    var length = !!obj && "length" in obj && obj.length,
        thistype = type(obj);

    if (thistype === "function" || isWindow(obj)) {
      return false;
    }

    return thistype === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
  }
  /**
   * 获取当前script标签
   */


  var currentlyAddingScript;
  var interactiveScript;

  function getCurrentScript() {
    if (document.currentScript) {
      return document.currentScript;
    }

    if (currentlyAddingScript) {
      return currentlyAddingScript;
    } // For IE6-9 browsers, the script onload event may not fire right
    // after the script is evaluated. Kris Zyp found that it
    // could query the script nodes and the one that is in "interactive"
    // mode indicates the current script
    // ref: http://goo.gl/JHfFW


    if (interactiveScript && interactiveScript.readyState === "interactive") {
      return interactiveScript;
    }

    var scripts = document.head.getElementsByTagName("script");

    for (var i = scripts.length - 1; i >= 0; i--) {
      var script = scripts[i];

      if (script.readyState === "interactive") {
        interactiveScript = script;
        return interactiveScript;
      }
    }

    return null;
  }
  /**
   * 加载器也是主要方法
   * @param {String} id 模块id
   * @param {Array} deps 模块依赖
   * @param {Function} callback 回调地址
   */


  function Dui(id, deps, factory) {
    //省略模块名
    if (typeof id !== 'string') {
      factory = deps;
      deps = id;
      id = null;
    } //无依赖


    if (!isArray(deps)) {
      factory = deps;
      deps = [];
    }

    var cfg = extend(true, {}, config),
        url = getIdUrl(id, cfg).split('?')[0];
    definedModules[url] = definedModules[url] || {};
    definedModules[url] = {
      id: id,
      //模块标识
      deps: deps,
      //模块依赖
      factory: factory,
      //模块工厂
      status: 'loaded',
      //模块状态
      oncomplete: definedModules[url].oncomplete || [],
      //模块回调参数
      config: cfg
    };
  }
  /**
   * 使用模块
   * @param {Array} deps 使用依赖
   * @param {Function} callback 回调地址
   */


  function use(deps, callback, options) {
    if (arguments.length < 2) {
      throw new Error('lodjs.use arguments miss');
      return 0;
    }

    if (typeof deps === 'string') {
      deps = [deps];
    }

    if (!isArray(deps) || !(typeof callback === "function")) {
      error('lodjs.use arguments type error');
      return 1;
    } // 如果没有依赖则直接运行函数


    if (deps.length === 0) {
      callback();
      return 2;
    }

    if (!isObject(options)) {
      options = extend(true, config, options);
    } // 如果页面已经存在jQuery1.7+库且所定义的模块依赖jQuery，则不加载内部jquery模块


    if (window.jQuery && jQuery.fn.on) {
      each(deps, function (index, item) {
        if (item === 'jquery') {
          var url = getIdUrl(item).split('?')[0];
          definedModules[url] = definedModules[url] || {};
          definedModules[url] = {
            id: item,
            //模块标识
            deps: [],
            //模块依赖
            factory: function factory() {
              return window.$;
            },
            //模块工厂
            status: 'loaded',
            //模块状态
            oncomplete: definedModules[url].oncomplete || [],
            //模块回调参数
            config: {}
          };
        }
      });
    }

    var depsCount = deps.length;
    var params = [];
    each(deps, function (i, mod) {
      (function (j) {
        loadMod(mod, function (param) {
          depsCount--;
          params[j] = param;

          if (depsCount === 0) {
            callback.apply(null, params);
          }
        }, options);
      })(i);
    });
    return 3;
  }
  /**
   * 加载模块
   * @param {String} name 名称
   * @param {function} callback 回调函数
   */


  function loadMod(id, callback, options) {
    // 当前的配置信息
    var cfg = extend(true, config, options),
        url = getDepUrl(id, cfg);
    cfg.id = id;
    if (!definedModules[url]) {
      definedModules[url] = {
        status: 'loading',
        exports: {},
        oncomplete: []
      };
      loadjs(url, function () {
        //如果define的不是函数
        if (!isFunction(definedModules[url].factory)) {
          execMod(url, callback);
          return 0;
        } //define的是函数


        use(definedModules[url].deps, function () {
          execMod(url, callback, slice.call(arguments, 0));
        }, {
          base: url
        });
        return 1;
      }, function () {
        definedModules[url].status === 'error';
        callback();
        execComplete(url); //加载失败执行队列
      }, cfg);
      return 0;
    } //加载失败


    if (definedModules[url].status === 'error') {
      callback();
      return 1;
    } //正在加载


    if (definedModules[url].status === 'loading') {
      definedModules[url].oncomplete.push(callback);
      return 1;
    } //加载完成
    //尚未执行完成


    if (!definedModules[url].exports) {
      //如果define的不是函数
      if (!isFunction(definedModules[url].factory)) {
        execMod(url, callback);
        return 2;
      } //define的是函数


      use(definedModules[url].deps, function () {
        execMod(url, callback, slice.call(arguments, 0));
      }, {
        base: url
      });
      return 3;
    } //已经执行过


    callback(definedModules[url].exports);
    return 4;
  }
  /**
   * 执行模块
   * @param {String} url 模块的地址
   * @param {Function} callback 回调地址
   * @param {Object} params 参数
   */


  function execMod(url, callback, params) {
    if (!params) {
      definedModules[url].exports = definedModules[url].factory;
    } else {
      var exp = definedModules[url].factory.apply(null, params);

      if (exp) {
        definedModules[url].exports = exp;
      }
    } //执行回调函数


    callback(definedModules[url].exports); // //执行complete队列

    execComplete(url);
  }
  /**
   * 函数定义完毕执行load函数
   * @param {url} url 模块的地址
   */


  function execComplete(url) {
    //模块定义完毕 执行load函数,当加载失败时，会不存在module
    for (var i = 0; i < definedModules[url].oncomplete.length; i++) {
      definedModules[url].oncomplete[i](definedModules[url] && definedModules[url].exports);
    } //释放内存


    definedModules[url].oncomplete = [];
  }
  /**
   * 
   * @param {String} src 需要加载的地址
   * @param {Function} success 成功回调地址
   * @param {Function} error 错误回调地址
   * @param {Object}} cfg 配置信息 
   */


  function loadjs(src, success, error, cfg) {
    var d = extend({
      charset: document.charset
    }, cfg);
    var node = document.createElement('script');
    node.src = src;
    node.modId = cfg.id;
    node.setAttribute(Dui.defaluts.plugins[config.id] ? 'dui-plugin' : 'dui-modules', cfg.id);
    node.charset = d.charset;

    if ('onload' in node) {
      node.onload = success;
      node.onerror = error;
    } else {
      node.onreadystatechange = function () {
        if (/loaded|complete/.test(node.readyState)) {
          success();
        }
      };
    }

    currentlyAddingScript = node;
    document.head.appendChild(node);
    currentlyAddingScript = null;
  }
  /**
   * 深度复制
   * @param {Object} target 属性
   */


  function extend(target) {
    var src,
        copyIsArray,
        copy,
        name,
        options,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

    if (typeof target === "boolean") {
      deep = target;
      target = arguments[i] || {};
      i++;
    }

    if (typeof target !== "object" && !isFunction(target)) {
      target = {};
    }

    if (i === length) {
      target = this;
      i--;
    }

    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];

          if (target === copy) {
            continue;
          }

          if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && isArray(src) ? src : [];
            } else {
              clone = src && isPlainObject(src) ? src : {};
            }

            target[name] = extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }

    return target;
  }
  /**
   * 循环函数
   * @param {Object} object 循环对象
   * @param {Function} callback 回调函数
   */


  function each(obj, callback) {
    var length,
        i = 0;

    if (isArrayLike(obj)) {
      length = obj.length;

      for (; i < length; i++) {
        if (callback.call(obj[i], i, obj[i]) === false) {
          break;
        }
      }
    } else {
      for (i in obj) {
        if (callback.call(obj[i], i, obj[i]) === false) {
          break;
        }
      }
    }

    return obj;
  }

  Dui.extend = extend;
  Dui.define = Dui;
  Dui.use = use;
  Dui.each = each;

  Dui.config = function (options) {
    // 如果给与的base不是带域名的路径
    if (!isUrl(options.base)) {
      //修复base
      var base = location.origin;

      if (options.base.search(/^\//) !== -1) {
        // 以/开头
        options.base = base + options.base;
      } else if (options.base.search(/^\.\//) !== -1) {
        base = location.href.slice(0, location.href.lastIndexOf('/') + 1); // 删除./

        options.base = options.base.slice(2, options.base.length); // 组装

        options.base = base + options.base;
      } else {
        throw new Error('参数base不能以../开头');
      }
    }

    config = extend(true, {}, config, options);
    return Dui;
  };

  if (!window.define) {
    window.define = Dui;

    if (typeof window.require !== 'function') {
      window.require = Dui.use;
    }
  }

  Dui.amd = {}; // 返回数据

  var isServer = typeof window === 'undefined';
  var ieVersion = isServer ? 0 : Number(document.documentMode);
  var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
  var MOZ_HACK_REGEXP = /^moz([A-Z])/;
  var camelCase = function camelCase(name) {
    return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
      return offset ? letter.toUpperCase() : letter;
    }).replace(MOZ_HACK_REGEXP, 'Moz$1');
  };
  /**
   * 去掉字符串空格
   * @param {String} string 需要去掉空格的字符串
   * @returns {String}   返回去掉空格后的字符串
   */

  function trim(string) {
    return (string || '').replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, '');
  }
  /**
   * 给dom绑定事件
   * @param {Element} el 要操作的dom节点
   * @param {String} type 时间类型
   * @param {function} fn 回调函数
   */

  var on = function () {
    if (document.addEventListener) {
      return function (element, event, handler) {
        if (element && event && handler) {
          element.addEventListener(event, handler, false);
        }
      };
    } else {
      return function (element, event, handler) {
        if (element && event && handler) {
          element.attachEvent('on' + event, handler);
        }
      };
    }
  }();
  /**
   * 给dom移除事件
   * @param {Element} el 要操作的dom节点
   * @param {String} type 事件类型
   * @param {function} fn 回调函数
   */

  var off = function () {
    if (document.removeEventListener) {
      return function (element, event, handler) {
        if (element && event) {
          element.removeEventListener(event, handler, false);
        }
      };
    } else {
      return function (element, event, handler) {
        if (element && event) {
          element.detachEvent('on' + event, handler);
        }
      };
    }
  }();
  /**
   * 给dom执行一次事件
   * @param {Element} el 操作的dom节点
   * @param {String} event 事件
   * @param {function} fn 回调函数
   */

  function once(el, event, fn) {
    var listener = function listener() {
      if (fn) {
        fn.apply(this, arguments);
      }

      off(el, event, listener);
    };

    on(el, event, listener);
  }
  /**
   * 判断元素是否包含该元素
   * @param {Element} el 操作的dom节点
   * @param {String} cls 查找的class
   */

  function hasClass(el, cls) {
    if (!el || !cls) return false;
    if (cls.indexOf(' ') !== -1) throw new Error('className should not contain space.');

    if (el.classList) {
      return el.classList.contains(cls);
    } else {
      return (' ' + el.className + ' ').indexOf(' ' + cls + ' ') > -1;
    }
  }
  /**
   * 给元素新增class
   * @param {Element} el 操作的dom节点
   * @param {String} cls 要增加的className
   */

  function addClass(el, cls) {
    if (!el) return;
    var curClass = el.className;
    var classes = (cls || '').split(' ');

    for (var i = 0, j = classes.length; i < j; i++) {
      var clsName = classes[i];
      if (!clsName) continue;

      if (el.classList) {
        el.classList.add(clsName);
      } else if (!hasClass(el, clsName)) {
        curClass += ' ' + clsName;
      }
    }

    if (!el.classList) {
      el.className = curClass;
    }
  }
  /**
   * 给元素移除class
   * @param {Element} el 操作的dom节点
   * @param {String} cls 要移除的className
   */

  function removeClass(el, cls) {
    if (!el || !cls) return;
    var classes = cls.split(' ');
    var curClass = ' ' + el.className + ' ';

    for (var i = 0, j = classes.length; i < j; i++) {
      var clsName = classes[i];
      if (!clsName) continue;

      if (el.classList) {
        el.classList.remove(clsName);
      } else if (hasClass(el, clsName)) {
        curClass = curClass.replace(' ' + clsName + ' ', ' ');
      }
    }

    if (!el.classList) {
      el.className = trim(curClass);
    }
  }
  /**
   * 获取元素的样式
   * @param {Element} element 要操作的dom节点
   * @param {String} styleName 要获取的属性名
   * @returns {String} 返回该style的值
   */

  var getStyle = ieVersion < 9 ? function (element, styleName) {
    if (!element || !styleName) return null;
    styleName = camelCase(styleName);

    if (styleName === 'float') {
      styleName = 'styleFloat';
    }

    try {
      switch (styleName) {
        case 'opacity':
          try {
            return element.filters.item('alpha').opacity / 100;
          } catch (e) {
            return 1.0;
          }

        default:
          return element.style[styleName] || element.currentStyle ? element.currentStyle[styleName] : null;
      }
    } catch (e) {
      return element.style[styleName];
    }
  } : function (element, styleName) {
    if (!element || !styleName) return null;
    styleName = camelCase(styleName);

    if (styleName === 'float') {
      styleName = 'cssFloat';
    }

    try {
      var computed = document.defaultView.getComputedStyle(element, '');
      return element.style[styleName] || computed ? computed[styleName] : null;
    } catch (e) {
      return element.style[styleName];
    }
  };
  /**
   * 给元素设置样式
   * @param {Element} element 操作的dom节点
   * @param {String} styleName 操作的属性名
   * @param {String} value 设置的属性值
   */

  function setStyle(element, styleName, value) {
    if (!element || !styleName) return;

    if (typeof styleName === 'object') {
      for (var prop in styleName) {
        if (styleName.hasOwnProperty(prop)) {
          setStyle(element, prop, styleName[prop]);
        }
      }
    } else {
      styleName = camelCase(styleName);

      if (styleName === 'opacity' && ieVersion < 9) {
        element.style.filter = isNaN(value) ? '' : 'alpha(opacity=' + value * 100 + ')';
      } else {
        element.style[styleName] = value;
      }
    }
  }
  /**
   * 当前浏览器的滚动条宽度
   */

  function scrollBarWidth() {
    var outer = document.createElement('div');
    outer.className = 'aiui-scrollbar-wrap';
    outer.style.visibility = 'hidden';
    outer.style.width = '100px';
    outer.style.position = 'absolute';
    outer.style.top = '-9999px';
    document.body.appendChild(outer);
    var widthNoScroll = outer.offsetWidth;
    outer.style.overflow = 'scroll';
    var inner = document.createElement('div');
    inner.style.width = '100%';
    outer.appendChild(inner);
    var widthWithScroll = inner.offsetWidth;
    outer.parentNode.removeChild(outer);
    var width = widthNoScroll - widthWithScroll;
    return width;
  }

  /**
   * 下一帧执行的方法
   */

  var nextFrame = window.requestAnimationFrame ? window.requestAnimationFrame : function (callback, element) {
    var currTime = new Date().getTime();
    var timeToCall = Math.max(0, 16.7 - (currTime - lastTime));
    window.setTimeout(function () {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };
  /**
   * 设置某个函数只执行一次
   * @param {function} fn 只使用一次的函数
   * @returns {function} fn 返回只执行一次的函数
   */

  function once$1(fn) {
    var called = false;
    return function () {
      if (!called) {
        called = true;
        fn.apply(this, arguments);
      }
    };
  }
  /**
   * 获取指定元素的模拟node
   * @param {Element} el 要获取Vnode的属性
   * @param {Object} defaultProp 要获取的默认属性
   * @param {Object} Prop 参数属性
   */

  function setVnode(el) {
    if (!el.vnode) {
      var vnode = {
        elm: el,
        data: {},
        event: {},
        attrs: {},
        props: {}
      };
      el.vnode = vnode;
    }
  }
  /**
   * 给元素设置dui识别数据
   * @param {Element} el 要设置属性的元素
   * @param {String} name 数据名称
   * @param {Object} option 传递的数据
   */

  function setData(el, name, option) {
    if (!el.vnode) {
      setVnode(el);
    }

    el.vnode.data[name] = extend(true, {}, option);
  }
  /**
   * 给网页元素设置方法//统一委托
   * @param {Element} el 要给那个设置回调方法
   * @param {String} name 要给那个组件设置
   * @param {String} type 设置什么方法
   * @param {function} fn 回调函数
   */

  function bind(el, name, type, fn) {
    if (!el.vnode) {
      setVnode(el);
    }

    if (!el.vnode.event[name]) {
      el.vnode.event[name] = {};
    }

    el.vnode.event[name][type] = fn;
  }
  /**
   * 给网页元素取消方法//统一委托
   * @param {Element} el 要给那个设置回调方法
   * @param {String} name 要给那个组件设置
   * @param {String} type 取消什么方法
   * @param {function} fn 回调函数
   */

  function unbind(el, name, type, fn) {
    if (!el.vnode) {
      return;
    }

    el.vnode.event[name] && el.vnode.event[name][type] && delete el.vnode.event[name][type];
  }
  /**
   * 给元素设置props
   * @param {Element} el 要设置属性的元素
   * @param {String} name 给哪个组件设置
   * @param {Object} propconfig 默认属性
   */

  function setProps(el, name, propconfig) {
    if (!el.vnode) {
      setVnode(el);
    }

    var attrs = el.attributes;
    el.vnode.attrs = {};
    each(attrs, function (key, attr) {
      var attrName = attr.name;
      var value = attr.nodeValue;
      el.vnode.attrs[attrName] = value;
    });
    el.vnode.props[name] = {};
    each(propconfig, function (k, info) {
      var thisk = toLowerLine(k).replace('', ''); //设置默认值

      if (el.vnode.attrs[thisk]) {
        //有值
        if (typeof info === "function") {
          if (info === Boolean) {
            el.vnode.props[name][k] = el.vnode.attrs[thisk] == 'true' ? true : false;
          } else if (info === Number) {
            el.vnode.props[name][k] = Number(el.vnode.attrs[thisk]);
          } else if (info === String) {
            el.vnode.props[name][k] = String(el.vnode.attrs[thisk]);
          }
        } else {
          if ('array' === type(info.type)) {
            var value;

            if (['true', 'false'].indexOf(el.vnode.attrs[thisk]) != -1) {
              value = el.vnode.attrs[thisk] == 'true' ? true : false;
            } else if (el.vnode.attrs[thisk] === Number(el.vnode.attrs[thisk]) + '') {
              value = Number(el.vnode.attrs[thisk]);
            } else {
              value = String(el.vnode.attrs[thisk]);
            }

            el.vnode.props[name][k] = value;
          } else {
            if (info.type(el.vnode.attrs[thisk])) {
              el.vnode.props[name][k] = info.type(el.vnode.attrs[thisk]);
            } else {
              if (typeof propconfig[k].default === "undefined") {
                var converFunction;

                if (type(propconfig[k].type) === 'array') {
                  converFunction = propconfig[k].type[0];
                } else {
                  converFunction = propconfig[k].type;
                }

                if (converFunction === Boolean) {
                  el.vnode.props[name][k] = false;
                } else if (converFunction === Number) {
                  el.vnode.props[name][k] = 0;
                } else {
                  el.vnode.props[name][k] = '';
                }
              }
            }
          }
        }
      } else {
        if (type(info) === 'function') {
          if (info === Boolean) {
            el.vnode.props[name][k] = false;
          } else if (info === Number) {
            el.vnode.props[name][k] = 0;
          } else {
            el.vnode.props[name][k] = '';
          }
        } else {
          if (typeof info.default !== "undefined") {
            el.vnode.props[name][k] = info.default;
          } else {
            var converFunction;

            if (type(info.type) === 'array') {
              converFunction = info.type[0];
            } else {
              converFunction = info.type;
            }

            if (converFunction === Boolean) {
              el.vnode.props[name][k] = false;
            } else if (converFunction === Number) {
              el.vnode.props[name][k] = 0;
            } else {
              el.vnode.props[name][k] = '';
            }
          }
        }
      }
    });
  }
  /**
   * 驼峰转呆横线的字符串
   * @param {Sting} str 要转换的字符串
   */

  function toLowerLine(str) {
    var temp = str.replace(/[A-Z]/g, function (match) {
      return "-" + match.toLowerCase();
    });

    if (temp.slice(0, 1) === '-') {
      //如果首字母是大写，执行replace时会多一个-，这里需要去掉
      temp = temp.slice(1);
    }

    return temp;
  }
  /**
   * 把一个字符串自动转到适应类型
   * @param {String} value 任何数
   * @param {any} convertType 要转换的类型
   */

  function convertProp(value, convertType) {
    if (type(convertType) === 'array') {
      if (['true', 'false'].indexOf(value) != -1) {
        value = value == 'true' ? true : false;
      } else if (value === Number(value) + '') {
        value = Number(value);
      } else {
        value = String(value);
      }
    } else {
      value = convertType(value);
    }

    return value;
  }
  /**
   * 获取当前页面最大的z-index
   */

  function getMaxZIndex() {
    var all = document.querySelectorAll('*');
    var maxZ = 0;
    each(all, function (index, item) {
      if (parseInt(getStyle(item, 'z-index')) > maxZ) {
        maxZ = parseInt(getStyle(item, 'z-index'));
      }
    });
    return maxZ;
  }

  function watch(option) {
    this.$data = type(option.data) === "object" ? extend(true, {}, option.data) : {};
    this.$watch = type(option.watch) === "object" ? extend(true, {}, option.watch) : {};
    this.$deep = type(option.deep) === "boolean" ? extend(true, {}, option).deep : false;
    this.defineProx();
  }

  watch.prototype.defineProx = function () {
    var that = this;

    var defineProperty = function defineProperty(data, prevKey, deep) {
      each(data, function (key, oldVal) {
        var fnKey = prevKey ? prevKey + '.' + key : key;

        if (!isPlainObject(data)) {
          return;
        }

        Object.defineProperty(data, key, {
          get: function get() {
            return oldVal;
          },
          set: function set(val) {
            var newVal = val;
            that.$watch[fnKey] && typeof that.$watch[fnKey] === "function" && that.$watch[fnKey](newVal, oldVal);
          }
        });

        if (deep && type(oldVal) === "object") {
          defineProperty(oldVal, fnKey, deep);
        }
      });
    };

    defineProperty(this.$data, null, that.$deep);
  };

  function watcher (option) {
    return new watch(option);
  }

  function Class(elem, options) {
    this.init(elem, options);
    return this;
  }
  /**
   * 过渡进入时发生
   * @param {Object} vnode nodeData对象
   */


  function enter(vnode) {
    var el = vnode.elm; // call leave callback now

    if (el._leaveCb) {
      el._leaveCb.cancelled = true;

      el._leaveCb();
    }

    var data = vnode.data.transition;

    if (!data) {
      return;
    }

    if (el._enterCb) {
      return;
    }

    var startClass = data.name + '-enter';
    var activeClass = data.name + '-enter-active';
    var toClass = data.name + '-enter-to'; // 4个生命周期钩子函数

    var beforeEnterHook = data.beforeEnter;
    var enterHook = data.enter;
    var afterEnterHook = data.afterEnter;
    var enterCancelledHook = data.enterCancelled;
    var cb = el._enterCb = once$1(function () {
      removeClass(el, toClass);
      removeClass(el, activeClass);

      if (cb.cancelled) {
        removeClass(el, startClass);
        enterCancelledHook && enterCancelledHook(el);
      } else {
        afterEnterHook && afterEnterHook(el);
      }

      el._enterCb = null;
    }); // 如果有回调函数

    beforeEnterHook && beforeEnterHook(el);
    addClass(el, startClass);
    addClass(el, activeClass);
    nextFrame(function () {
      setStyle(el, 'display', '');
      nextFrame(function () {
        removeClass(el, startClass);

        if (!cb.cancelled) {
          // 添加 v-enter-to
          addClass(el, toClass);

          if (enterHook && typeof enterHook === "function") {
            enterHook(el, cb);
          } else {
            setTimeout(cb, data.duration);
          }
        }
      });
    });
  }
  /**
   * 过渡离开时发生
   * @param {Object} vnode nodeData对象
   */

  function leave(vnode) {
    var el = vnode.elm; // call leave callback now

    if (el._enterCb) {
      el._enterCb.cancelled = true;

      el._enterCb();
    }

    var data = vnode.data.transition;

    if (!data) {
      return;
    }

    if (el._leaveCb) {
      return;
    }

    var startClass = data.name + '-leave';
    var activeClass = data.name + '-leave-active';
    var toClass = data.name + '-leave-to'; // 4个生命周期钩子函数

    var beforeLeaveHook = data.beforeLeave;
    var leaveHook = data.leave;
    var afterLeaveHook = data.afterLeave;
    var leaveCancelledHook = data.leaveCancelled;
    var cb = el._leaveCb = once$1(function () {
      removeClass(el, toClass);
      removeClass(el, activeClass);

      if (cb.cancelled) {
        removeClass(el, startClass);
        leaveCancelledHook && leaveCancelledHook(el);
      } else {
        afterLeaveHook && afterLeaveHook(el);
        setStyle(el, 'display', 'none');
      }

      el._leaveCb = null;
    }); // 如果有回调函数

    beforeLeaveHook && beforeLeaveHook(el);
    addClass(el, startClass);
    addClass(el, activeClass);
    nextFrame(function () {
      removeClass(el, startClass);

      if (!cb.cancelled) {
        // 添加 v-enter-to
        addClass(el, toClass);

        if (leaveHook && typeof leaveHook === "function") {
          leaveHook(el, cb);
        } else {
          setTimeout(cb, data.duration);
        }
      }
    });
  }
  Class.prototype = Class.fn = {
    init: function init(elem, options) {
      var that = this;
      that.elem = elem;
      options = extend(true, {
        name: 'face',
        elem: elem,
        duration: 300,
        //过渡时间
        beforeEnter: '',
        //进入前
        enter: '',
        //当与 CSS 结合使用时
        afterEnter: '',
        //过渡后回调
        enterCancelled: '',
        //取消过渡回调
        beforeLeave: '',
        //离开前回调
        leave: '',
        //当与 CSS 结合使用时
        afterLeave: '',
        //离开之后回调
        leaveCancelled: '',
        //取消的时候回调
        show: true //默认是否显示

      }, options); //设置数据

      setData(elem, 'transition', options); //获取data

      var data = that.data = elem.vnode.data.transition; //设置状态

      that.status = data.show === true ? 'show' : 'hide';
      that.watcher = watcher({
        data: data,
        watch: {
          show: function show(newVal, oldVal) {
            if (newVal === true) {
              that.status = 'show';
              enter(elem.vnode);
            } else {
              that.status = 'hide';
              leave(elem.vnode);
            }
          }
        }
      }); //如果默认为不显示

      if (data.show === false) {
        setStyle(elem, 'display', 'none');
      }

      return that;
    },
    show: function show() {
      this.watcher.$data.show = true;
    },
    hide: function hide() {
      this.watcher.$data.show = false;
    }
  };

  var transition = function transition(elem, options) {
    return new Class(elem, options);
  };

  function collapseTransition(el, option) {
    option = extend(true, {
      show: false
    }, option);
    return transition(el, {
      name: 'collapse',
      beforeEnter: function beforeEnter(el) {
        addClass(el, 'collapse-transition');
        if (!el.dataset) el.dataset = {};
        el.dataset.oldPaddingTop = el.style.paddingTop;
        el.dataset.oldPaddingBottom = el.style.paddingBottom;
        el.style.height = '0';
        el.style.paddingTop = 0;
        el.style.paddingBottom = 0;
        el.style.overflow = 'hidden';
      },
      enter: function enter(el, cb) {
        el.dataset.oldOverflow = el.style.overflow;

        if (el.scrollHeight !== 0) {
          el.style.height = el.scrollHeight + 'px';
          el.style.paddingTop = el.dataset.oldPaddingTop;
          el.style.paddingBottom = el.dataset.oldPaddingBottom;
        } else {
          el.style.height = '';
          el.style.paddingTop = el.dataset.oldPaddingTop;
          el.style.paddingBottom = el.dataset.oldPaddingBottom;
        }

        setTimeout(cb, 300);
      },
      afterEnter: function afterEnter(el) {
        removeClass(el, 'collapse-transition');
        el.style.height = '';
        el.style.overflow = el.dataset.oldOverflow;
      },
      beforeLeave: function beforeLeave(el) {
        if (!el.dataset) el.dataset = {};
        el.dataset.oldPaddingTop = el.style.paddingTop;
        el.dataset.oldPaddingBottom = el.style.paddingBottom;
        el.dataset.oldOverflow = el.style.overflow;
        el.style.height = el.scrollHeight + 'px';
        el.style.overflow = 'hidden';
      },
      leave: function leave(el, cb) {
        if (el.scrollHeight !== 0) {
          // for safari: add class after set height, or it will jump to zero height suddenly, weired
          addClass(el, 'collapse-transition');
          el.style.height = 0;
          el.style.paddingTop = 0;
          el.style.paddingBottom = 0;
        }

        setTimeout(cb, 300);
      },
      afterLeave: function afterLeave(el) {
        removeClass(el, 'collapse-transition');
        el.style.height = '';
        el.style.overflow = el.dataset.oldOverflow;
        el.style.paddingTop = el.dataset.oldPaddingTop;
        el.style.paddingBottom = el.dataset.oldPaddingBottom;
        option.afterLeave && option.afterLeave(el);
      },
      show: option.show
    });
  }

  var root = window; // default options

  var DEFAULTS = {
    // placement of the popper
    placement: 'bottom',
    gpuAcceleration: false,
    // shift popper from its origin by the given amount of pixels (can be negative)
    offset: 0,
    // the element which will act as boundary of the popper
    boundariesElement: 'viewport',
    // amount of pixel used to define a minimum distance between the boundaries and the popper
    boundariesPadding: 5,
    // popper will try to prevent overflow following this order,
    // by default, then, it could overflow on the left and on top of the boundariesElement
    preventOverflowOrder: ['left', 'right', 'top', 'bottom'],
    // the behavior used by flip to change the placement of the popper
    flipBehavior: 'flip',
    arrowElement: '[x-arrow]',
    arrowOffset: 0,
    // list of functions used to modify the offsets before they are applied to the popper
    modifiers: ['shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle'],
    modifiersIgnored: [],
    forceAbsolute: false
  };
  /**
   * Create a new Popper.js instance
   * @constructor Popper
   * @param {HTMLElement} reference - The reference element used to position the popper
   * @param {HTMLElement|Object} popper
   *      The HTML element used as popper, or a configuration used to generate the popper.
   * @param {String} [popper.tagName='div'] The tag name of the generated popper.
   * @param {Array} [popper.classNames=['popper']] Array of classes to apply to the generated popper.
   * @param {Array} [popper.attributes] Array of attributes to apply, specify `attr:value` to assign a value to it.
   * @param {HTMLElement|String} [popper.parent=window.document.body] The parent element, given as HTMLElement or as query string.
   * @param {String} [popper.content=''] The content of the popper, it can be text, html, or node; if it is not text, set `contentType` to `html` or `node`.
   * @param {String} [popper.contentType='text'] If `html`, the `content` will be parsed as HTML. If `node`, it will be appended as-is.
   * @param {String} [popper.arrowTagName='div'] Same as `popper.tagName` but for the arrow element.
   * @param {Array} [popper.arrowClassNames='popper__arrow'] Same as `popper.classNames` but for the arrow element.
   * @param {String} [popper.arrowAttributes=['x-arrow']] Same as `popper.attributes` but for the arrow element.
   * @param {Object} options
   * @param {String} [options.placement=bottom]
   *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -right),
   *      left(-start, -end)`
   *
   * @param {HTMLElement|String} [options.arrowElement='[x-arrow]']
   *      The DOM Node used as arrow for the popper, or a CSS selector used to get the DOM node. It must be child of
   *      its parent Popper. Popper.js will apply to the given element the style required to align the arrow with its
   *      reference element.
   *      By default, it will look for a child node of the popper with the `x-arrow` attribute.
   *
   * @param {Boolean} [options.gpuAcceleration=true]
   *      When this property is set to true, the popper position will be applied using CSS3 translate3d, allowing the
   *      browser to use the GPU to accelerate the rendering.
   *      If set to false, the popper will be placed using `top` and `left` properties, not using the GPU.
   *
   * @param {Number} [options.offset=0]
   *      Amount of pixels the popper will be shifted (can be negative).
   *
   * @param {String|Element} [options.boundariesElement='viewport']
   *      The element which will define the boundaries of the popper position, the popper will never be placed outside
   *      of the defined boundaries (except if `keepTogether` is enabled)
   *
   * @param {Number} [options.boundariesPadding=5]
   *      Additional padding for the boundaries
   *
   * @param {Array} [options.preventOverflowOrder=['left', 'right', 'top', 'bottom']]
   *      Order used when Popper.js tries to avoid overflows from the boundaries, they will be checked in order,
   *      this means that the last ones will never overflow
   *
   * @param {String|Array} [options.flipBehavior='flip']
   *      The behavior used by the `flip` modifier to change the placement of the popper when the latter is trying to
   *      overlap its reference element. Defining `flip` as value, the placement will be flipped on
   *      its axis (`right - left`, `top - bottom`).
   *      You can even pass an array of placements (eg: `['right', 'left', 'top']` ) to manually specify
   *      how alter the placement when a flip is needed. (eg. in the above example, it would first flip from right to left,
   *      then, if even in its new placement, the popper is overlapping its reference element, it will be moved to top)
   *
   * @param {Array} [options.modifiers=[ 'shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle']]
   *      List of functions used to modify the data before they are applied to the popper, add your custom functions
   *      to this array to edit the offsets and placement.
   *      The function should reflect the @params and @returns of preventOverflow
   *
   * @param {Array} [options.modifiersIgnored=[]]
   *      Put here any built-in modifier name you want to exclude from the modifiers list
   *      The function should reflect the @params and @returns of preventOverflow
   *
   * @param {Boolean} [options.removeOnDestroy=false]
   *      Set to true if you want to automatically remove the popper when you call the `destroy` method.
   */

  function Popper(reference, popper, options) {
    this._reference = reference.jquery ? reference[0] : reference;
    this.state = {}; // if the popper variable is a configuration object, parse it to generate an HTMLElement
    // generate a default popper if is not defined

    var isNotDefined = typeof popper === 'undefined' || popper === null;
    var isConfig = popper && Object.prototype.toString.call(popper) === '[object Object]';

    if (isNotDefined || isConfig) {
      this._popper = this.parse(isConfig ? popper : {});
    } // otherwise, use the given HTMLElement as popper
    else {
        this._popper = popper.jquery ? popper[0] : popper;
      } // with {} we create a new object with the options inside it


    this._options = Object.assign({}, DEFAULTS, options); // refactoring modifiers' list

    this._options.modifiers = this._options.modifiers.map(function (modifier) {
      // remove ignored modifiers
      if (this._options.modifiersIgnored.indexOf(modifier) !== -1) return; // set the x-placement attribute before everything else because it could be used to add margins to the popper
      // margins needs to be calculated to get the correct popper offsets

      if (modifier === 'applyStyle') {
        this._popper.setAttribute('x-placement', this._options.placement);
      } // return predefined modifier identified by string or keep the custom one


      return this.modifiers[modifier] || modifier;
    }.bind(this)); // make sure to apply the popper position before any computation

    this.state.position = this._getPosition(this._popper, this._reference);
    setStyle$1(this._popper, {
      position: this.state.position,
      top: 0
    }); // fire the first update to position the popper in the right place

    this.update(); // setup event listeners, they will take care of update the position in specific situations

    this._setupEventListeners();

    return this;
  } //
  // Methods
  //

  /**
   * Destroy the popper
   * @method
   * @memberof Popper
   */


  Popper.prototype.destroy = function () {
    this._popper.removeAttribute('x-placement');

    this._popper.style.left = '';
    this._popper.style.position = '';
    this._popper.style.top = '';
    this._popper.style[getSupportedPropertyName('transform')] = '';

    this._removeEventListeners(); // remove the popper if user explicity asked for the deletion on destroy


    if (this._options.removeOnDestroy) {
      this._popper.remove();
    }

    return this;
  };
  /**
   * Updates the position of the popper, computing the new offsets and applying the new style
   * @method
   * @memberof Popper
   */


  Popper.prototype.update = function () {
    var data = {
      instance: this,
      styles: {}
    }; // store placement inside the data object, modifiers will be able to edit `placement` if needed
    // and refer to _originalPlacement to know the original value

    data.placement = this._options.placement;
    data._originalPlacement = this._options.placement; // compute the popper and reference offsets and put them inside data.offsets

    data.offsets = this._getOffsets(this._popper, this._reference, data.placement); // get boundaries

    data.boundaries = this._getBoundaries(data, this._options.boundariesPadding, this._options.boundariesElement);
    data = this.runModifiers(data, this._options.modifiers);

    if (typeof this.state.updateCallback === 'function') {
      this.state.updateCallback(data);
    }
  };
  /**
   * If a function is passed, it will be executed after the initialization of popper with as first argument the Popper instance.
   * @method
   * @memberof Popper
   * @param {Function} callback
   */


  Popper.prototype.onCreate = function (callback) {
    // the createCallbacks return as first argument the popper instance
    callback(this);
    return this;
  };
  /**
   * If a function is passed, it will be executed after each update of popper with as first argument the set of coordinates and informations
   * used to style popper and its arrow.
   * NOTE: it doesn't get fired on the first call of the `Popper.update()` method inside the `Popper` constructor!
   * @method
   * @memberof Popper
   * @param {Function} callback
   */


  Popper.prototype.onUpdate = function (callback) {
    this.state.updateCallback = callback;
    return this;
  };
  /**
   * Helper used to generate poppers from a configuration file
   * @method
   * @memberof Popper
   * @param config {Object} configuration
   * @returns {HTMLElement} popper
   */


  Popper.prototype.parse = function (config) {
    var defaultConfig = {
      tagName: 'div',
      classNames: ['popper'],
      attributes: [],
      parent: root.document.body,
      content: '',
      contentType: 'text',
      arrowTagName: 'div',
      arrowClassNames: ['popper__arrow'],
      arrowAttributes: ['x-arrow']
    };
    config = Object.assign({}, defaultConfig, config);
    var d = root.document;
    var popper = d.createElement(config.tagName);
    addClassNames(popper, config.classNames);
    addAttributes(popper, config.attributes);

    if (config.contentType === 'node') {
      popper.appendChild(config.content.jquery ? config.content[0] : config.content);
    } else if (config.contentType === 'html') {
      popper.innerHTML = config.content;
    } else {
      popper.textContent = config.content;
    }

    if (config.arrowTagName) {
      var arrow = d.createElement(config.arrowTagName);
      addClassNames(arrow, config.arrowClassNames);
      addAttributes(arrow, config.arrowAttributes);
      popper.appendChild(arrow);
    }

    var parent = config.parent.jquery ? config.parent[0] : config.parent; // if the given parent is a string, use it to match an element
    // if more than one element is matched, the first one will be used as parent
    // if no elements are matched, the script will throw an error

    if (typeof parent === 'string') {
      parent = d.querySelectorAll(config.parent);

      if (parent.length > 1) {
        console.warn('WARNING: the given `parent` query(' + config.parent + ') matched more than one element, the first one will be used');
      }

      if (parent.length === 0) {
        throw 'ERROR: the given `parent` doesn\'t exists!';
      }

      parent = parent[0];
    } // if the given parent is a DOM nodes list or an array of nodes with more than one element,
    // the first one will be used as parent


    if (parent.length > 1 && parent instanceof Element === false) {
      console.warn('WARNING: you have passed as parent a list of elements, the first one will be used');
      parent = parent[0];
    } // append the generated popper to its parent


    parent.appendChild(popper);
    return popper;
    /**
     * Adds class names to the given element
     * @function
     * @ignore
     * @param {HTMLElement} target
     * @param {Array} classes
     */

    function addClassNames(element, classNames) {
      classNames.forEach(function (className) {
        element.classList.add(className);
      });
    }
    /**
     * Adds attributes to the given element
     * @function
     * @ignore
     * @param {HTMLElement} target
     * @param {Array} attributes
     * @example
     * addAttributes(element, [ 'data-info:foobar' ]);
     */


    function addAttributes(element, attributes) {
      attributes.forEach(function (attribute) {
        element.setAttribute(attribute.split(':')[0], attribute.split(':')[1] || '');
      });
    }
  };
  /**
   * Helper used to get the position which will be applied to the popper
   * @method
   * @memberof Popper
   * @param config {HTMLElement} popper element
   * @param reference {HTMLElement} reference element
   * @returns {String} position
   */


  Popper.prototype._getPosition = function (popper, reference) {
    var container = getOffsetParent(reference);

    if (this._options.forceAbsolute) {
      return 'absolute';
    } // Decide if the popper will be fixed
    // If the reference element is inside a fixed context, the popper will be fixed as well to allow them to scroll together


    var isParentFixed = isFixed(reference);
    return isParentFixed ? 'fixed' : 'absolute';
  };
  /**
   * Get offsets to the popper
   * @method
   * @memberof Popper
   * @access private
   * @param {Element} popper - the popper element
   * @param {Element} reference - the reference element (the popper will be relative to this)
   * @returns {Object} An object containing the offsets which will be applied to the popper
   */


  Popper.prototype._getOffsets = function (popper, reference, placement) {
    placement = placement.split('-')[0];
    var popperOffsets = {};
    popperOffsets.position = this.state.position;
    var isParentFixed = popperOffsets.position === 'fixed'; //
    // Get reference element position
    //

    var referenceOffsets = getOffsetRectRelativeToCustomParent(reference, getOffsetParent(popper), isParentFixed); //
    // Get popper sizes
    //

    var popperRect = getOuterSizes(popper); //
    // Compute offsets of popper
    //
    // depending by the popper placement we have to compute its offsets slightly differently

    if (['right', 'left'].indexOf(placement) !== -1) {
      popperOffsets.top = referenceOffsets.top + referenceOffsets.height / 2 - popperRect.height / 2;

      if (placement === 'left') {
        popperOffsets.left = referenceOffsets.left - popperRect.width;
      } else {
        popperOffsets.left = referenceOffsets.right;
      }
    } else {
      popperOffsets.left = referenceOffsets.left + referenceOffsets.width / 2 - popperRect.width / 2;

      if (placement === 'top') {
        popperOffsets.top = referenceOffsets.top - popperRect.height;
      } else {
        popperOffsets.top = referenceOffsets.bottom;
      }
    } // Add width and height to our offsets object


    popperOffsets.width = popperRect.width;
    popperOffsets.height = popperRect.height;
    return {
      popper: popperOffsets,
      reference: referenceOffsets
    };
  };
  /**
   * Setup needed event listeners used to update the popper position
   * @method
   * @memberof Popper
   * @access private
   */


  Popper.prototype._setupEventListeners = function () {
    // NOTE: 1 DOM access here
    this.state.updateBound = this.update.bind(this);
    root.addEventListener('resize', this.state.updateBound); // if the boundariesElement is window we don't need to listen for the scroll event

    if (this._options.boundariesElement !== 'window') {
      var target = getScrollParent(this._reference); // here it could be both `body` or `documentElement` thanks to Firefox, we then check both

      if (target === root.document.body || target === root.document.documentElement) {
        target = root;
      }

      target.addEventListener('scroll', this.state.updateBound);
      this.state.scrollTarget = target;
    }
  };
  /**
   * Remove event listeners used to update the popper position
   * @method
   * @memberof Popper
   * @access private
   */


  Popper.prototype._removeEventListeners = function () {
    // NOTE: 1 DOM access here
    root.removeEventListener('resize', this.state.updateBound);

    if (this._options.boundariesElement !== 'window' && this.state.scrollTarget) {
      this.state.scrollTarget.removeEventListener('scroll', this.state.updateBound);
      this.state.scrollTarget = null;
    }

    this.state.updateBound = null;
  };
  /**
   * Computed the boundaries limits and return them
   * @method
   * @memberof Popper
   * @access private
   * @param {Object} data - Object containing the property "offsets" generated by `_getOffsets`
   * @param {Number} padding - Boundaries padding
   * @param {Element} boundariesElement - Element used to define the boundaries
   * @returns {Object} Coordinates of the boundaries
   */


  Popper.prototype._getBoundaries = function (data, padding, boundariesElement) {
    // NOTE: 1 DOM access here
    var boundaries = {};
    var width, height;

    if (boundariesElement === 'window') {
      var body = root.document.body,
          html = root.document.documentElement;
      height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
      width = Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);
      boundaries = {
        top: 0,
        right: width,
        bottom: height,
        left: 0
      };
    } else if (boundariesElement === 'viewport') {
      var offsetParent = getOffsetParent(this._popper);
      var scrollParent = getScrollParent(this._popper);
      var offsetParentRect = getOffsetRect(offsetParent); // Thanks the fucking native API, `document.body.scrollTop` & `document.documentElement.scrollTop`

      var getScrollTopValue = function getScrollTopValue(element) {
        return element == document.body ? Math.max(document.documentElement.scrollTop, document.body.scrollTop) : element.scrollTop;
      };

      var getScrollLeftValue = function getScrollLeftValue(element) {
        return element == document.body ? Math.max(document.documentElement.scrollLeft, document.body.scrollLeft) : element.scrollLeft;
      }; // if the popper is fixed we don't have to substract scrolling from the boundaries


      var scrollTop = data.offsets.popper.position === 'fixed' ? 0 : getScrollTopValue(scrollParent);
      var scrollLeft = data.offsets.popper.position === 'fixed' ? 0 : getScrollLeftValue(scrollParent);
      boundaries = {
        top: 0 - (offsetParentRect.top - scrollTop),
        right: root.document.documentElement.clientWidth - (offsetParentRect.left - scrollLeft),
        bottom: root.document.documentElement.clientHeight - (offsetParentRect.top - scrollTop),
        left: 0 - (offsetParentRect.left - scrollLeft)
      };
    } else {
      if (getOffsetParent(this._popper) === boundariesElement) {
        boundaries = {
          top: 0,
          left: 0,
          right: boundariesElement.clientWidth,
          bottom: boundariesElement.clientHeight
        };
      } else {
        boundaries = getOffsetRect(boundariesElement);
      }
    }

    boundaries.left += padding;
    boundaries.right -= padding;
    boundaries.top = boundaries.top + padding;
    boundaries.bottom = boundaries.bottom - padding;
    return boundaries;
  };
  /**
   * Loop trough the list of modifiers and run them in order, each of them will then edit the data object
   * @method
   * @memberof Popper
   * @access public
   * @param {Object} data
   * @param {Array} modifiers
   * @param {Function} ends
   */


  Popper.prototype.runModifiers = function (data, modifiers, ends) {
    var modifiersToRun = modifiers.slice();

    if (ends !== undefined) {
      modifiersToRun = this._options.modifiers.slice(0, getArrayKeyIndex(this._options.modifiers, ends));
    }

    modifiersToRun.forEach(function (modifier) {
      if (isFunction$1(modifier)) {
        data = modifier.call(this, data);
      }
    }.bind(this));
    return data;
  };
  /**
   * Helper used to know if the given modifier depends from another one.
   * @method
   * @memberof Popper
   * @param {String} requesting - name of requesting modifier
   * @param {String} requested - name of requested modifier
   * @returns {Boolean}
   */


  Popper.prototype.isModifierRequired = function (requesting, requested) {
    var index = getArrayKeyIndex(this._options.modifiers, requesting);
    return !!this._options.modifiers.slice(0, index).filter(function (modifier) {
      return modifier === requested;
    }).length;
  }; //
  // Modifiers
  //

  /**
   * Modifiers list
   * @namespace Popper.modifiers
   * @memberof Popper
   * @type {Object}
   */


  Popper.prototype.modifiers = {};
  /**
   * Apply the computed styles to the popper element
   * @method
   * @memberof Popper.modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @returns {Object} The same data object
   */

  Popper.prototype.modifiers.applyStyle = function (data) {
    // apply the final offsets to the popper
    // NOTE: 1 DOM access here
    var styles = {
      position: data.offsets.popper.position
    }; // round top and left to avoid blurry text

    var left = Math.round(data.offsets.popper.left);
    var top = Math.round(data.offsets.popper.top); // if gpuAcceleration is set to true and transform is supported, we use `translate3d` to apply the position to the popper
    // we automatically use the supported prefixed version if needed

    var prefixedProperty;

    if (this._options.gpuAcceleration && (prefixedProperty = getSupportedPropertyName('transform'))) {
      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
      styles.top = 0;
      styles.left = 0;
    } // othwerise, we use the standard `left` and `top` properties
    else {
        styles.left = left;
        styles.top = top;
      } // any property present in `data.styles` will be applied to the popper,
    // in this way we can make the 3rd party modifiers add custom styles to it
    // Be aware, modifiers could override the properties defined in the previous
    // lines of this modifier!


    Object.assign(styles, data.styles);
    setStyle$1(this._popper, styles); // set an attribute which will be useful to style the tooltip (use it to properly position its arrow)
    // NOTE: 1 DOM access here

    this._popper.setAttribute('x-placement', data.placement); // if the arrow modifier is required and the arrow style has been computed, apply the arrow style


    if (this.isModifierRequired(this.modifiers.applyStyle, this.modifiers.arrow) && data.offsets.arrow) {
      setStyle$1(data.arrowElement, data.offsets.arrow);
    }

    return data;
  };
  /**
   * Modifier used to shift the popper on the start or end of its reference element side
   * @method
   * @memberof Popper.modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @returns {Object} The data object, properly modified
   */


  Popper.prototype.modifiers.shift = function (data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var shiftVariation = placement.split('-')[1]; // if shift shiftVariation is specified, run the modifier

    if (shiftVariation) {
      var reference = data.offsets.reference;
      var popper = getPopperClientRect(data.offsets.popper);
      var shiftOffsets = {
        y: {
          start: {
            top: reference.top
          },
          end: {
            top: reference.top + reference.height - popper.height
          }
        },
        x: {
          start: {
            left: reference.left
          },
          end: {
            left: reference.left + reference.width - popper.width
          }
        }
      };
      var axis = ['bottom', 'top'].indexOf(basePlacement) !== -1 ? 'x' : 'y';
      data.offsets.popper = Object.assign(popper, shiftOffsets[axis][shiftVariation]);
    }

    return data;
  };
  /**
   * Modifier used to make sure the popper does not overflows from it's boundaries
   * @method
   * @memberof Popper.modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @returns {Object} The data object, properly modified
   */


  Popper.prototype.modifiers.preventOverflow = function (data) {
    var order = this._options.preventOverflowOrder;
    var popper = getPopperClientRect(data.offsets.popper);
    var check = {
      left: function left() {
        var left = popper.left;

        if (popper.left < data.boundaries.left) {
          left = Math.max(popper.left, data.boundaries.left);
        }

        return {
          left: left
        };
      },
      right: function right() {
        var left = popper.left;

        if (popper.right > data.boundaries.right) {
          left = Math.min(popper.left, data.boundaries.right - popper.width);
        }

        return {
          left: left
        };
      },
      top: function top() {
        var top = popper.top;

        if (popper.top < data.boundaries.top) {
          top = Math.max(popper.top, data.boundaries.top);
        }

        return {
          top: top
        };
      },
      bottom: function bottom() {
        var top = popper.top;

        if (popper.bottom > data.boundaries.bottom) {
          top = Math.min(popper.top, data.boundaries.bottom - popper.height);
        }

        return {
          top: top
        };
      }
    };
    order.forEach(function (direction) {
      data.offsets.popper = Object.assign(popper, check[direction]());
    });
    return data;
  };
  /**
   * Modifier used to make sure the popper is always near its reference
   * @method
   * @memberof Popper.modifiers
   * @argument {Object} data - The data object generated by _update method
   * @returns {Object} The data object, properly modified
   */


  Popper.prototype.modifiers.keepTogether = function (data) {
    var popper = getPopperClientRect(data.offsets.popper);
    var reference = data.offsets.reference;
    var f = Math.floor;

    if (popper.right < f(reference.left)) {
      data.offsets.popper.left = f(reference.left) - popper.width;
    }

    if (popper.left > f(reference.right)) {
      data.offsets.popper.left = f(reference.right);
    }

    if (popper.bottom < f(reference.top)) {
      data.offsets.popper.top = f(reference.top) - popper.height;
    }

    if (popper.top > f(reference.bottom)) {
      data.offsets.popper.top = f(reference.bottom);
    }

    return data;
  };
  /**
   * Modifier used to flip the placement of the popper when the latter is starting overlapping its reference element.
   * Requires the `preventOverflow` modifier before it in order to work.
   * **NOTE:** This modifier will run all its previous modifiers everytime it tries to flip the popper!
   * @method
   * @memberof Popper.modifiers
   * @argument {Object} data - The data object generated by _update method
   * @returns {Object} The data object, properly modified
   */


  Popper.prototype.modifiers.flip = function (data) {
    // check if preventOverflow is in the list of modifiers before the flip modifier.
    // otherwise flip would not work as expected.
    if (!this.isModifierRequired(this.modifiers.flip, this.modifiers.preventOverflow)) {
      console.warn('WARNING: preventOverflow modifier is required by flip modifier in order to work, be sure to include it before flip!');
      return data;
    }

    if (data.flipped && data.placement === data._originalPlacement) {
      // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
      return data;
    }

    var placement = data.placement.split('-')[0];
    var placementOpposite = getOppositePlacement(placement);
    var variation = data.placement.split('-')[1] || '';
    var flipOrder = [];

    if (this._options.flipBehavior === 'flip') {
      flipOrder = [placement, placementOpposite];
    } else {
      flipOrder = this._options.flipBehavior;
    }

    flipOrder.forEach(function (step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return;
      }

      placement = data.placement.split('-')[0];
      placementOpposite = getOppositePlacement(placement);
      var popperOffsets = getPopperClientRect(data.offsets.popper); // this boolean is used to distinguish right and bottom from top and left
      // they need different computations to get flipped

      var a = ['right', 'bottom'].indexOf(placement) !== -1; // using Math.floor because the reference offsets may contain decimals we are not going to consider here

      if (a && Math.floor(data.offsets.reference[placement]) > Math.floor(popperOffsets[placementOpposite]) || !a && Math.floor(data.offsets.reference[placement]) < Math.floor(popperOffsets[placementOpposite])) {
        // we'll use this boolean to detect any flip loop
        data.flipped = true;
        data.placement = flipOrder[index + 1];

        if (variation) {
          data.placement += '-' + variation;
        }

        data.offsets.popper = this._getOffsets(this._popper, this._reference, data.placement).popper;
        data = this.runModifiers(data, this._options.modifiers, this._flip);
      }
    }.bind(this));
    return data;
  };
  /**
   * Modifier used to add an offset to the popper, useful if you more granularity positioning your popper.
   * The offsets will shift the popper on the side of its reference element.
   * @method
   * @memberof Popper.modifiers
   * @argument {Object} data - The data object generated by _update method
   * @returns {Object} The data object, properly modified
   */


  Popper.prototype.modifiers.offset = function (data) {
    var offset = this._options.offset;
    var popper = data.offsets.popper;

    if (data.placement.indexOf('left') !== -1) {
      popper.top -= offset;
    } else if (data.placement.indexOf('right') !== -1) {
      popper.top += offset;
    } else if (data.placement.indexOf('top') !== -1) {
      popper.left -= offset;
    } else if (data.placement.indexOf('bottom') !== -1) {
      popper.left += offset;
    }

    return data;
  };
  /**
   * Modifier used to move the arrows on the edge of the popper to make sure them are always between the popper and the reference element
   * It will use the CSS outer size of the arrow element to know how many pixels of conjuction are needed
   * @method
   * @memberof Popper.modifiers
   * @argument {Object} data - The data object generated by _update method
   * @returns {Object} The data object, properly modified
   */


  Popper.prototype.modifiers.arrow = function (data) {
    var arrow = this._options.arrowElement;
    var arrowOffset = this._options.arrowOffset; // if the arrowElement is a string, suppose it's a CSS selector

    if (typeof arrow === 'string') {
      arrow = this._popper.querySelector(arrow);
    } // if arrow element is not found, don't run the modifier


    if (!arrow) {
      return data;
    } // the arrow element must be child of its popper


    if (!this._popper.contains(arrow)) {
      console.warn('WARNING: `arrowElement` must be child of its popper element!');
      return data;
    } // arrow depends on keepTogether in order to work


    if (!this.isModifierRequired(this.modifiers.arrow, this.modifiers.keepTogether)) {
      console.warn('WARNING: keepTogether modifier is required by arrow modifier in order to work, be sure to include it before arrow!');
      return data;
    }

    var arrowStyle = {};
    var placement = data.placement.split('-')[0];
    var popper = getPopperClientRect(data.offsets.popper);
    var reference = data.offsets.reference;
    var isVertical = ['left', 'right'].indexOf(placement) !== -1;
    var len = isVertical ? 'height' : 'width';
    var side = isVertical ? 'top' : 'left';
    var altSide = isVertical ? 'left' : 'top';
    var opSide = isVertical ? 'bottom' : 'right';
    var arrowSize = getOuterSizes(arrow)[len]; //
    // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction
    //
    // top/left side

    if (reference[opSide] - arrowSize < popper[side]) {
      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowSize);
    } // bottom/right side


    if (reference[side] + arrowSize > popper[opSide]) {
      data.offsets.popper[side] += reference[side] + arrowSize - popper[opSide];
    } // compute center of the popper


    var center = reference[side] + (arrowOffset || reference[len] / 2 - arrowSize / 2);
    var sideValue = center - popper[side]; // prevent arrow from being placed not contiguously to its popper

    sideValue = Math.max(Math.min(popper[len] - arrowSize - 8, sideValue), 8);
    arrowStyle[side] = sideValue;
    arrowStyle[altSide] = ''; // make sure to remove any old style from the arrow

    data.offsets.arrow = arrowStyle;
    data.arrowElement = arrow;
    return data;
  }; //
  // Helpers
  //

  /**
   * Get the outer sizes of the given element (offset size + margins)
   * @function
   * @ignore
   * @argument {Element} element
   * @returns {Object} object containing width and height properties
   */


  function getOuterSizes(element) {
    // NOTE: 1 DOM access here
    var _display = element.style.display,
        _visibility = element.style.visibility;
    element.style.display = 'block';
    element.style.visibility = 'hidden';
    var calcWidthToForceRepaint = element.offsetWidth; // original method

    var styles = root.getComputedStyle(element);
    var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
    var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
    var result = {
      width: element.offsetWidth + y,
      height: element.offsetHeight + x
    }; // reset element styles

    element.style.display = _display;
    element.style.visibility = _visibility;
    return result;
  }
  /**
   * Get the opposite placement of the given one/
   * @function
   * @ignore
   * @argument {String} placement
   * @returns {String} flipped placement
   */


  function getOppositePlacement(placement) {
    var hash = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched];
    });
  }
  /**
   * Given the popper offsets, generate an output similar to getBoundingClientRect
   * @function
   * @ignore
   * @argument {Object} popperOffsets
   * @returns {Object} ClientRect like output
   */


  function getPopperClientRect(popperOffsets) {
    var offsets = Object.assign({}, popperOffsets);
    offsets.right = offsets.left + offsets.width;
    offsets.bottom = offsets.top + offsets.height;
    return offsets;
  }
  /**
   * Given an array and the key to find, returns its index
   * @function
   * @ignore
   * @argument {Array} arr
   * @argument keyToFind
   * @returns index or null
   */


  function getArrayKeyIndex(arr, keyToFind) {
    var i = 0,
        key;

    for (key in arr) {
      if (arr[key] === keyToFind) {
        return i;
      }

      i++;
    }

    return null;
  }
  /**
   * Get CSS computed property of the given element
   * @function
   * @ignore
   * @argument {Eement} element
   * @argument {String} property
   */


  function getStyleComputedProperty(element, property) {
    // NOTE: 1 DOM access here
    var css = root.getComputedStyle(element, null);
    return css[property];
  }
  /**
   * Returns the offset parent of the given element
   * @function
   * @ignore
   * @argument {Element} element
   * @returns {Element} offset parent
   */


  function getOffsetParent(element) {
    // NOTE: 1 DOM access here
    var offsetParent = element.offsetParent;
    return offsetParent === root.document.body || !offsetParent ? root.document.documentElement : offsetParent;
  }
  /**
   * Returns the scrolling parent of the given element
   * @function
   * @ignore
   * @argument {Element} element
   * @returns {Element} offset parent
   */


  function getScrollParent(element) {
    var parent = element.parentNode;

    if (!parent) {
      return element;
    }

    if (parent === root.document) {
      // Firefox puts the scrollTOp value on `documentElement` instead of `body`, we then check which of them is
      // greater than 0 and return the proper element
      if (root.document.body.scrollTop || root.document.body.scrollLeft) {
        return root.document.body;
      } else {
        return root.document.documentElement;
      }
    } // Firefox want us to check `-x` and `-y` variations as well


    if (['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow')) !== -1 || ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-x')) !== -1 || ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-y')) !== -1) {
      // If the detected scrollParent is body, we perform an additional check on its parentNode
      // in this way we'll get body if the browser is Chrome-ish, or documentElement otherwise
      // fixes issue #65
      return parent;
    }

    return getScrollParent(element.parentNode);
  }
  /**
   * Check if the given element is fixed or is inside a fixed parent
   * @function
   * @ignore
   * @argument {Element} element
   * @argument {Element} customContainer
   * @returns {Boolean} answer to "isFixed?"
   */


  function isFixed(element) {
    if (element === root.document.body) {
      return false;
    }

    if (getStyleComputedProperty(element, 'position') === 'fixed') {
      return true;
    }

    return element.parentNode ? isFixed(element.parentNode) : element;
  }
  /**
   * Set the style to the given popper
   * @function
   * @ignore
   * @argument {Element} element - Element to apply the style to
   * @argument {Object} styles - Object with a list of properties and values which will be applied to the element
   */


  function setStyle$1(element, styles) {
    function is_numeric(n) {
      return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
    }

    Object.keys(styles).forEach(function (prop) {
      var unit = ''; // add unit if the value is numeric and is one of the following

      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && is_numeric(styles[prop])) {
        unit = 'px';
      }

      element.style[prop] = styles[prop] + unit;
    });
  }
  /**
   * Check if the given variable is a function
   * @function
   * @ignore
   * @argument {*} functionToCheck - variable to check
   * @returns {Boolean} answer to: is a function?
   */


  function isFunction$1(functionToCheck) {
    var getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
  }
  /**
   * Get the position of the given element, relative to its offset parent
   * @function
   * @ignore
   * @param {Element} element
   * @return {Object} position - Coordinates of the element and its `scrollTop`
   */


  function getOffsetRect(element) {
    var elementRect = {
      width: element.offsetWidth,
      height: element.offsetHeight,
      left: element.offsetLeft,
      top: element.offsetTop
    };
    elementRect.right = elementRect.left + elementRect.width;
    elementRect.bottom = elementRect.top + elementRect.height; // position

    return elementRect;
  }
  /**
   * Get bounding client rect of given element
   * @function
   * @ignore
   * @param {HTMLElement} element
   * @return {Object} client rect
   */


  function getBoundingClientRect(element) {
    var rect = element.getBoundingClientRect(); // whether the IE version is lower than 11

    var isIE = navigator.userAgent.indexOf("MSIE") != -1; // fix ie document bounding top always 0 bug

    var rectTop = isIE && element.tagName === 'HTML' ? -element.scrollTop : rect.top;
    return {
      left: rect.left,
      top: rectTop,
      right: rect.right,
      bottom: rect.bottom,
      width: rect.right - rect.left,
      height: rect.bottom - rectTop
    };
  }
  /**
   * Given an element and one of its parents, return the offset
   * @function
   * @ignore
   * @param {HTMLElement} element
   * @param {HTMLElement} parent
   * @return {Object} rect
   */


  function getOffsetRectRelativeToCustomParent(element, parent, fixed) {
    var elementRect = getBoundingClientRect(element);
    var parentRect = getBoundingClientRect(parent);

    if (fixed) {
      var scrollParent = getScrollParent(parent);
      parentRect.top += scrollParent.scrollTop;
      parentRect.bottom += scrollParent.scrollTop;
      parentRect.left += scrollParent.scrollLeft;
      parentRect.right += scrollParent.scrollLeft;
    }

    var rect = {
      top: elementRect.top - parentRect.top,
      left: elementRect.left - parentRect.left,
      bottom: elementRect.top - parentRect.top + elementRect.height,
      right: elementRect.left - parentRect.left + elementRect.width,
      width: elementRect.width,
      height: elementRect.height
    };
    return rect;
  }
  /**
   * Get the prefixed supported property name
   * @function
   * @ignore
   * @argument {String} property (camelCase)
   * @returns {String} prefixed property (camelCase)
   */


  function getSupportedPropertyName(property) {
    var prefixes = ['', 'ms', 'webkit', 'moz', 'o'];

    for (var i = 0; i < prefixes.length; i++) {
      var toCheck = prefixes[i] ? prefixes[i] + property.charAt(0).toUpperCase() + property.slice(1) : property;

      if (typeof root.document.body.style[toCheck] !== 'undefined') {
        return toCheck;
      }
    }

    return null;
  }
  /**
   * The Object.assign() method is used to copy the values of all enumerable own properties from one or more source
   * objects to a target object. It will return the target object.
   * This polyfill doesn't support symbol properties, since ES5 doesn't have symbols anyway
   * Source: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
   * @function
   * @ignore
   */


  if (!Object.assign) {
    Object.defineProperty(Object, 'assign', {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function value(target) {
        if (target === undefined || target === null) {
          throw new TypeError('Cannot convert first argument to object');
        }

        var to = Object(target);

        for (var i = 1; i < arguments.length; i++) {
          var nextSource = arguments[i];

          if (nextSource === undefined || nextSource === null) {
            continue;
          }

          nextSource = Object(nextSource);
          var keysArray = Object.keys(nextSource);

          for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
            var nextKey = keysArray[nextIndex];
            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

            if (desc !== undefined && desc.enumerable) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }

        return to;
      }
    });
  }

  var stop = function stop(e) {
    return e.stopPropagation();
  };

  var Class$1 = function Class(reference, popper, options) {
    var that = this,
        createCallback = that.createCallback = extend(true, {}, options).onCreate,
        updateCallback = that.updateCallback = extend(true, {}, options).onUpdate;
    that.reference = reference;
    that.popperElm = popper; // 删除多余的

    delete options['onCreate'] && delete options['onUpdate']; // 创建popper

    that.popperJS = new Popper(reference, popper, options); //设置修改方法

    if (typeof createCallback === 'function') {
      that.popperJS.onCreate(createCallback);
    } //设置修改方法


    if (typeof updateCallback === 'function') {
      that.popperJS.onUpdate(updateCallback);
    }

    that.popperJS._popper.style.zIndex = getMaxZIndex() + 1;
    on(that.popperElm, 'click', stop);
    on(window, 'resize', function () {
      that.updatePopper();
    });
  };

  Class$1.prototype.updatePopper = function (fn) {
    var popperJS = this.popperJS,
        that = this;

    if (popperJS) {
      if (fn) {
        popperJS.onUpdate(function (data) {
          fn.call(that, data);
          popperJS.onUpdate(that.updateCallback);
        });
      }

      popperJS.update();

      if (popperJS._popper) {
        popperJS._popper.style.zIndex = getMaxZIndex() + 1;
      }
    } else {
      this.createPopper();
    }
  };

  function addPopper (reference, popper, options) {
    return new Class$1(reference, popper, options);
  }

  /**
   * A collection of shims that provide minimal functionality of the ES6 collections.
   *
   * These implementations are not meant to be used outside of the ResizeObserver
   * modules as they cover only a limited range of use cases.
   */

  /* eslint-disable require-jsdoc, valid-jsdoc */
  var MapShim = function () {
    if (typeof Map !== 'undefined') {
      return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */


    function getIndex(arr, key) {
      var result = -1;
      arr.some(function (entry, index) {
        if (entry[0] === key) {
          result = index;
          return true;
        }

        return false;
      });
      return result;
    }

    return (
      /** @class */
      function () {
        function class_1() {
          this.__entries__ = [];
        }

        Object.defineProperty(class_1.prototype, "size", {
          /**
           * @returns {boolean}
           */
          get: function () {
            return this.__entries__.length;
          },
          enumerable: true,
          configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */

        class_1.prototype.get = function (key) {
          var index = getIndex(this.__entries__, key);
          var entry = this.__entries__[index];
          return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */


        class_1.prototype.set = function (key, value) {
          var index = getIndex(this.__entries__, key);

          if (~index) {
            this.__entries__[index][1] = value;
          } else {
            this.__entries__.push([key, value]);
          }
        };
        /**
         * @param {*} key
         * @returns {void}
         */


        class_1.prototype.delete = function (key) {
          var entries = this.__entries__;
          var index = getIndex(entries, key);

          if (~index) {
            entries.splice(index, 1);
          }
        };
        /**
         * @param {*} key
         * @returns {void}
         */


        class_1.prototype.has = function (key) {
          return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */


        class_1.prototype.clear = function () {
          this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */


        class_1.prototype.forEach = function (callback, ctx) {
          if (ctx === void 0) {
            ctx = null;
          }

          for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
            var entry = _a[_i];
            callback.call(ctx, entry[1], entry[0]);
          }
        };

        return class_1;
      }()
    );
  }();
  /**
   * Detects whether window and document objects are available in current environment.
   */


  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document; // Returns global object of a current environment.

  var global$1 = function () {
    if (typeof global !== 'undefined' && global.Math === Math) {
      return global;
    }

    if (typeof self !== 'undefined' && self.Math === Math) {
      return self;
    }

    if (typeof window !== 'undefined' && window.Math === Math) {
      return window;
    } // eslint-disable-next-line no-new-func


    return Function('return this')();
  }();
  /**
   * A shim for the requestAnimationFrame which falls back to the setTimeout if
   * first one is not supported.
   *
   * @returns {number} Requests' identifier.
   */


  var requestAnimationFrame$1 = function () {
    if (typeof requestAnimationFrame === 'function') {
      // It's required to use a bounded function because IE sometimes throws
      // an "Invalid calling object" error if rAF is invoked without the global
      // object on the left hand side.
      return requestAnimationFrame.bind(global$1);
    }

    return function (callback) {
      return setTimeout(function () {
        return callback(Date.now());
      }, 1000 / 60);
    };
  }(); // Defines minimum timeout before adding a trailing call.


  var trailingTimeout = 2;
  /**
   * Creates a wrapper function which ensures that provided callback will be
   * invoked only once during the specified delay period.
   *
   * @param {Function} callback - Function to be invoked after the delay period.
   * @param {number} delay - Delay after which to invoke callback.
   * @returns {Function}
   */

  function throttle(callback, delay) {
    var leadingCall = false,
        trailingCall = false,
        lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */

    function resolvePending() {
      if (leadingCall) {
        leadingCall = false;
        callback();
      }

      if (trailingCall) {
        proxy();
      }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */


    function timeoutCallback() {
      requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */


    function proxy() {
      var timeStamp = Date.now();

      if (leadingCall) {
        // Reject immediately following calls.
        if (timeStamp - lastCallTime < trailingTimeout) {
          return;
        } // Schedule new call to be in invoked when the pending one is resolved.
        // This is important for "transitions" which never actually start
        // immediately so there is a chance that we might miss one if change
        // happens amids the pending invocation.


        trailingCall = true;
      } else {
        leadingCall = true;
        trailingCall = false;
        setTimeout(timeoutCallback, delay);
      }

      lastCallTime = timeStamp;
    }

    return proxy;
  } // Minimum delay before invoking the update of observers.


  var REFRESH_DELAY = 20; // A list of substrings of CSS properties used to find transition events that
  // might affect dimensions of observed elements.

  var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight']; // Check if MutationObserver is available.

  var mutationObserverSupported = typeof MutationObserver !== 'undefined';
  /**
   * Singleton controller class which handles updates of ResizeObserver instances.
   */

  var ResizeObserverController =
  /** @class */
  function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
      /**
       * Indicates whether DOM listeners have been added.
       *
       * @private {boolean}
       */
      this.connected_ = false;
      /**
       * Tells that controller has subscribed for Mutation Events.
       *
       * @private {boolean}
       */

      this.mutationEventsAdded_ = false;
      /**
       * Keeps reference to the instance of MutationObserver.
       *
       * @private {MutationObserver}
       */

      this.mutationsObserver_ = null;
      /**
       * A list of connected observers.
       *
       * @private {Array<ResizeObserverSPI>}
       */

      this.observers_ = [];
      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
      this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */


    ResizeObserverController.prototype.addObserver = function (observer) {
      if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
      } // Add listeners if they haven't been added yet.


      if (!this.connected_) {
        this.connect_();
      }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */


    ResizeObserverController.prototype.removeObserver = function (observer) {
      var observers = this.observers_;
      var index = observers.indexOf(observer); // Remove observer if it's present in registry.

      if (~index) {
        observers.splice(index, 1);
      } // Remove listeners if controller has no connected observers.


      if (!observers.length && this.connected_) {
        this.disconnect_();
      }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */


    ResizeObserverController.prototype.refresh = function () {
      var changesDetected = this.updateObservers_(); // Continue running updates if changes have been detected as there might
      // be future ones caused by CSS transitions.

      if (changesDetected) {
        this.refresh();
      }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */


    ResizeObserverController.prototype.updateObservers_ = function () {
      // Collect observers that have active observations.
      var activeObservers = this.observers_.filter(function (observer) {
        return observer.gatherActive(), observer.hasActive();
      }); // Deliver notifications in a separate cycle in order to avoid any
      // collisions between observers, e.g. when multiple instances of
      // ResizeObserver are tracking the same element and the callback of one
      // of them changes content dimensions of the observed target. Sometimes
      // this may result in notifications being blocked for the rest of observers.

      activeObservers.forEach(function (observer) {
        return observer.broadcastActive();
      });
      return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */


    ResizeObserverController.prototype.connect_ = function () {
      // Do nothing if running in a non-browser environment or if listeners
      // have been already added.
      if (!isBrowser || this.connected_) {
        return;
      } // Subscription to the "Transitionend" event is used as a workaround for
      // delayed transitions. This way it's possible to capture at least the
      // final state of an element.


      document.addEventListener('transitionend', this.onTransitionEnd_);
      window.addEventListener('resize', this.refresh);

      if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        this.mutationsObserver_.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      } else {
        document.addEventListener('DOMSubtreeModified', this.refresh);
        this.mutationEventsAdded_ = true;
      }

      this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */


    ResizeObserverController.prototype.disconnect_ = function () {
      // Do nothing if running in a non-browser environment or if listeners
      // have been already removed.
      if (!isBrowser || !this.connected_) {
        return;
      }

      document.removeEventListener('transitionend', this.onTransitionEnd_);
      window.removeEventListener('resize', this.refresh);

      if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
      }

      if (this.mutationEventsAdded_) {
        document.removeEventListener('DOMSubtreeModified', this.refresh);
      }

      this.mutationsObserver_ = null;
      this.mutationEventsAdded_ = false;
      this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */


    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
      var _b = _a.propertyName,
          propertyName = _b === void 0 ? '' : _b; // Detect whether transition may affect dimensions of an element.

      var isReflowProperty = transitionKeys.some(function (key) {
        return !!~propertyName.indexOf(key);
      });

      if (isReflowProperty) {
        this.refresh();
      }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */


    ResizeObserverController.getInstance = function () {
      if (!this.instance_) {
        this.instance_ = new ResizeObserverController();
      }

      return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */


    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
  }();
  /**
   * Defines non-writable/enumerable properties of the provided target object.
   *
   * @param {Object} target - Object for which to define properties.
   * @param {Object} props - Properties to be defined.
   * @returns {Object} Target object.
   */


  var defineConfigurable = function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
      var key = _a[_i];
      Object.defineProperty(target, key, {
        value: props[key],
        enumerable: false,
        writable: false,
        configurable: true
      });
    }

    return target;
  };
  /**
   * Returns the global object associated with provided element.
   *
   * @param {Object} target
   * @returns {Object}
   */


  var getWindowOf = function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView; // Return the local global object if it's not possible extract one from
    // provided element.

    return ownerGlobal || global$1;
  }; // Placeholder of an empty content rectangle.


  var emptyRect = createRectInit(0, 0, 0, 0);
  /**
   * Converts provided string to a number.
   *
   * @param {number|string} value
   * @returns {number}
   */

  function toFloat(value) {
    return parseFloat(value) || 0;
  }
  /**
   * Extracts borders size from provided styles.
   *
   * @param {CSSStyleDeclaration} styles
   * @param {...string} positions - Borders positions (top, right, ...)
   * @returns {number}
   */


  function getBordersSize(styles) {
    var positions = [];

    for (var _i = 1; _i < arguments.length; _i++) {
      positions[_i - 1] = arguments[_i];
    }

    return positions.reduce(function (size, position) {
      var value = styles['border-' + position + '-width'];
      return size + toFloat(value);
    }, 0);
  }
  /**
   * Extracts paddings sizes from provided styles.
   *
   * @param {CSSStyleDeclaration} styles
   * @returns {Object} Paddings box.
   */


  function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};

    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
      var position = positions_1[_i];
      var value = styles['padding-' + position];
      paddings[position] = toFloat(value);
    }

    return paddings;
  }
  /**
   * Calculates content rectangle of provided SVG element.
   *
   * @param {SVGGraphicsElement} target - Element content rectangle of which needs
   *      to be calculated.
   * @returns {DOMRectInit}
   */


  function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
  }
  /**
   * Calculates content rectangle of provided HTMLElement.
   *
   * @param {HTMLElement} target - Element for which to calculate the content rectangle.
   * @returns {DOMRectInit}
   */


  function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth,
        clientHeight = target.clientHeight; // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.

    if (!clientWidth && !clientHeight) {
      return emptyRect;
    }

    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom; // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.

    var width = toFloat(styles.width),
        height = toFloat(styles.height); // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).

    if (styles.boxSizing === 'border-box') {
      // Following conditions are required to handle Internet Explorer which
      // doesn't include paddings and borders to computed CSS dimensions.
      //
      // We can say that if CSS dimensions + paddings are equal to the "client"
      // properties then it's either IE, and thus we don't need to subtract
      // anything, or an element merely doesn't have paddings/borders styles.
      if (Math.round(width + horizPad) !== clientWidth) {
        width -= getBordersSize(styles, 'left', 'right') + horizPad;
      }

      if (Math.round(height + vertPad) !== clientHeight) {
        height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
      }
    } // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.


    if (!isDocumentElement(target)) {
      // In some browsers (only in Firefox, actually) CSS width & height
      // include scroll bars size which can be removed at this step as scroll
      // bars are the only difference between rounded dimensions + paddings
      // and "client" properties, though that is not always true in Chrome.
      var vertScrollbar = Math.round(width + horizPad) - clientWidth;
      var horizScrollbar = Math.round(height + vertPad) - clientHeight; // Chrome has a rather weird rounding of "client" properties.
      // E.g. for an element with content width of 314.2px it sometimes gives
      // the client width of 315px and for the width of 314.7px it may give
      // 314px. And it doesn't happen all the time. So just ignore this delta
      // as a non-relevant.

      if (Math.abs(vertScrollbar) !== 1) {
        width -= vertScrollbar;
      }

      if (Math.abs(horizScrollbar) !== 1) {
        height -= horizScrollbar;
      }
    }

    return createRectInit(paddings.left, paddings.top, width, height);
  }
  /**
   * Checks whether provided element is an instance of the SVGGraphicsElement.
   *
   * @param {Element} target - Element to be checked.
   * @returns {boolean}
   */


  var isSVGGraphicsElement = function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
      return function (target) {
        return target instanceof getWindowOf(target).SVGGraphicsElement;
      };
    } // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens


    return function (target) {
      return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function';
    };
  }();
  /**
   * Checks whether provided element is a document element (<html>).
   *
   * @param {Element} target - Element to be checked.
   * @returns {boolean}
   */


  function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
  }
  /**
   * Calculates an appropriate content rectangle for provided html or svg element.
   *
   * @param {Element} target - Element content rectangle of which needs to be calculated.
   * @returns {DOMRectInit}
   */


  function getContentRect(target) {
    if (!isBrowser) {
      return emptyRect;
    }

    if (isSVGGraphicsElement(target)) {
      return getSVGContentRect(target);
    }

    return getHTMLElementContentRect(target);
  }
  /**
   * Creates rectangle with an interface of the DOMRectReadOnly.
   * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
   *
   * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
   * @returns {DOMRectReadOnly}
   */


  function createReadOnlyRect(_a) {
    var x = _a.x,
        y = _a.y,
        width = _a.width,
        height = _a.height; // If DOMRectReadOnly is available use it as a prototype for the rectangle.

    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype); // Rectangle's properties are not writable and non-enumerable.

    defineConfigurable(rect, {
      x: x,
      y: y,
      width: width,
      height: height,
      top: y,
      right: x + width,
      bottom: height + y,
      left: x
    });
    return rect;
  }
  /**
   * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
   * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
   *
   * @param {number} x - X coordinate.
   * @param {number} y - Y coordinate.
   * @param {number} width - Rectangle's width.
   * @param {number} height - Rectangle's height.
   * @returns {DOMRectInit}
   */


  function createRectInit(x, y, width, height) {
    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  }
  /**
   * Class that is responsible for computations of the content rectangle of
   * provided DOM element and for keeping track of it's changes.
   */


  var ResizeObservation =
  /** @class */
  function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
      /**
       * Broadcasted width of content rectangle.
       *
       * @type {number}
       */
      this.broadcastWidth = 0;
      /**
       * Broadcasted height of content rectangle.
       *
       * @type {number}
       */

      this.broadcastHeight = 0;
      /**
       * Reference to the last observed content rectangle.
       *
       * @private {DOMRectInit}
       */

      this.contentRect_ = createRectInit(0, 0, 0, 0);
      this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */


    ResizeObservation.prototype.isActive = function () {
      var rect = getContentRect(this.target);
      this.contentRect_ = rect;
      return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */


    ResizeObservation.prototype.broadcastRect = function () {
      var rect = this.contentRect_;
      this.broadcastWidth = rect.width;
      this.broadcastHeight = rect.height;
      return rect;
    };

    return ResizeObservation;
  }();

  var ResizeObserverEntry =
  /** @class */
  function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
      var contentRect = createReadOnlyRect(rectInit); // According to the specification following properties are not writable
      // and are also not enumerable in the native implementation.
      //
      // Property accessors are not being used as they'd require to define a
      // private WeakMap storage which may cause memory leaks in browsers that
      // don't support this type of collections.

      defineConfigurable(this, {
        target: target,
        contentRect: contentRect
      });
    }

    return ResizeObserverEntry;
  }();

  var ResizeObserverSPI =
  /** @class */
  function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
      /**
       * Collection of resize observations that have detected changes in dimensions
       * of elements.
       *
       * @private {Array<ResizeObservation>}
       */
      this.activeObservations_ = [];
      /**
       * Registry of the ResizeObservation instances.
       *
       * @private {Map<Element, ResizeObservation>}
       */

      this.observations_ = new MapShim();

      if (typeof callback !== 'function') {
        throw new TypeError('The callback provided as parameter 1 is not a function.');
      }

      this.callback_ = callback;
      this.controller_ = controller;
      this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */


    ResizeObserverSPI.prototype.observe = function (target) {
      if (!arguments.length) {
        throw new TypeError('1 argument required, but only 0 present.');
      } // Do nothing if current environment doesn't have the Element interface.


      if (typeof Element === 'undefined' || !(Element instanceof Object)) {
        return;
      }

      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }

      var observations = this.observations_; // Do nothing if element is already being observed.

      if (observations.has(target)) {
        return;
      }

      observations.set(target, new ResizeObservation(target));
      this.controller_.addObserver(this); // Force the update of observations.

      this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */


    ResizeObserverSPI.prototype.unobserve = function (target) {
      if (!arguments.length) {
        throw new TypeError('1 argument required, but only 0 present.');
      } // Do nothing if current environment doesn't have the Element interface.


      if (typeof Element === 'undefined' || !(Element instanceof Object)) {
        return;
      }

      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }

      var observations = this.observations_; // Do nothing if element is not being observed.

      if (!observations.has(target)) {
        return;
      }

      observations.delete(target);

      if (!observations.size) {
        this.controller_.removeObserver(this);
      }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */


    ResizeObserverSPI.prototype.disconnect = function () {
      this.clearActive();
      this.observations_.clear();
      this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */


    ResizeObserverSPI.prototype.gatherActive = function () {
      var _this = this;

      this.clearActive();
      this.observations_.forEach(function (observation) {
        if (observation.isActive()) {
          _this.activeObservations_.push(observation);
        }
      });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */


    ResizeObserverSPI.prototype.broadcastActive = function () {
      // Do nothing if observer doesn't have active observations.
      if (!this.hasActive()) {
        return;
      }

      var ctx = this.callbackCtx_; // Create ResizeObserverEntry instance for every active observation.

      var entries = this.activeObservations_.map(function (observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
      });
      this.callback_.call(ctx, entries, ctx);
      this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */


    ResizeObserverSPI.prototype.clearActive = function () {
      this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */


    ResizeObserverSPI.prototype.hasActive = function () {
      return this.activeObservations_.length > 0;
    };

    return ResizeObserverSPI;
  }(); // Registry of internal observers. If WeakMap is not available use current shim
  // for the Map collection as it has all required methods and because WeakMap
  // can't be fully polyfilled anyway.


  var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
  /**
   * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
   * exposing only those methods and properties that are defined in the spec.
   */

  var ResizeObserver =
  /** @class */
  function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
      if (!(this instanceof ResizeObserver)) {
        throw new TypeError('Cannot call a class as a function.');
      }

      if (!arguments.length) {
        throw new TypeError('1 argument required, but only 0 present.');
      }

      var controller = ResizeObserverController.getInstance();
      var observer = new ResizeObserverSPI(callback, controller, this);
      observers.set(this, observer);
    }

    return ResizeObserver;
  }(); // Expose public methods of ResizeObserver.


  ['observe', 'unobserve', 'disconnect'].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
      var _a;

      return (_a = observers.get(this))[method].apply(_a, arguments);
    };
  });

  var index = function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
      return global$1.ResizeObserver;
    }

    return ResizeObserver;
  }();

  var isServer$1 = typeof window === 'undefined'; //监听元素大小发生变化

  /* istanbul ignore next */

  var resizeHandler = function resizeHandler(entries) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var entry = _step.value;
        var listeners = entry.target.__resizeListeners__ || [];

        if (listeners.length) {
          listeners.forEach(function (fn) {
            fn();
          });
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  };
  /* istanbul ignore next */


  var addResizeListener = function addResizeListener(element, fn) {
    if (isServer$1) return;

    if (!element.__resizeListeners__) {
      element.__resizeListeners__ = [];
      element.__ro__ = new index(resizeHandler);

      element.__ro__.observe(element);
    }

    element.__resizeListeners__.push(fn);
  };
  /* istanbul ignore next */

  var removeResizeListener = function removeResizeListener(element, fn) {
    if (!element || !element.__resizeListeners__) return;

    element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);

    if (!element.__resizeListeners__.length) {
      element.__ro__.disconnect();
    }
  };

  var ClassName = {
    scroll: 'dui-scrollbar'
  },
      BAR_MAP = {
    vertical: {
      offset: 'offsetHeight',
      scroll: 'scrollTop',
      scrollSize: 'scrollHeight',
      size: 'height',
      key: 'vertical',
      axis: 'Y',
      client: 'clientY',
      direction: 'top'
    },
    horizontal: {
      offset: 'offsetWidth',
      scroll: 'scrollLeft',
      scrollSize: 'scrollWidth',
      size: 'width',
      key: 'horizontal',
      axis: 'X',
      client: 'clientX',
      direction: 'left'
    }
  };

  function scrollbar(el, options) {
    //创建根节点
    var that = this;
    that.original = el; //这是需要添加滚动条的元素

    setData(el, 'scrollbar', options);
    that.data = el.vnode.data.scrollbar; // 创建scroll

    that.scroll = document.createElement('div');
    addClass(that.scroll, ClassName.scroll); // 创建wrap

    that.wrap = document.createElement('div');
    that.scroll.append(that.wrap);
    that.moveX = 0;
    that.moveY = 0;
    that.sizeWidth = '0', that.sizeHeight = '0', // 初始化
    that.init();
  }

  scrollbar.prototype.init = function () {
    var that = this;
    var gutter = scrollBarWidth();
    var style = that.data.wrapStyle;

    if (gutter) {
      var gutterWith = "-".concat(gutter, "px");
      var gutterStyle = "margin-bottom: ".concat(gutterWith, "; margin-right: ").concat(gutterWith, ";");

      if (typeof this.wrapStyle === 'string') {
        style += gutterStyle;
      } else {
        style = gutterStyle;
      }
    } // 设置wrap的class


    that.wrap.className = 'dui-scrollbar__wrap' + (that.data.wrapClass ? ' ' + that.data.wrapClass : '') + (!gutter ? ' dui-scrollbar__wrap--hidden-default' : ''); // 设置样式

    style ? that.wrap.style = style : '';
    that.setSize(); // 设置bar

    that.barX = new bar(that, {
      vertical: false,
      size: that.sizeWidth,
      move: that.moveX
    });
    that.barY = new bar(that, {
      vertical: true,
      size: that.sizeHeight,
      move: that.moveY
    }); // 把元素放置在滚动里面

    that.original.parentNode ? that.original.parentNode.insertBefore(that.scroll, that.original) : document.body.append(that.scroll);
    that.wrap.append(that.original);
    that.update(); // 设置事件

    on(that.wrap, 'scroll', function (e) {
      that.moveY = that.wrap.scrollTop * 100 / that.wrap.clientHeight;
      that.moveX = that.wrap.scrollLeft * 100 / that.wrap.clientWidth;
      that.barY.thumb.style.transform = 'translateY(' + that.moveY + '%)';
      that.barX.thumb.style.transform = 'translateX(' + that.moveX + '%)';
    }); // 元素大小发生变化事件

    !that.data.noresize && addResizeListener(that.original, function () {
      that.update();
    });
  };

  scrollbar.prototype.setSize = function () {
    var that = this,
        heightPercentage,
        widthPercentage;
    var wrap = this.wrap;
    if (!wrap) return;
    heightPercentage = wrap.clientHeight * 100 / wrap.scrollHeight;
    widthPercentage = wrap.clientWidth * 100 / wrap.scrollWidth;
    that.sizeHeight = heightPercentage < 100 ? heightPercentage + '%' : '';
    that.sizeWidth = widthPercentage < 100 ? widthPercentage + '%' : '';
  }; //手动修改


  scrollbar.prototype.update = function () {
    var that = this;
    that.setSize();
    that.barY.thumb.style.height = that.sizeHeight;
    that.barX.thumb.style.width = that.sizeWidth;
  };

  function bar(parent, options) {
    var that = this;
    var bar = that.config = extend(true, {}, BAR_MAP[options.vertical ? 'vertical' : 'horizontal']); //创建的配置

    var size = options.size ? options.size : ''; //大小

    var move = options.move ? options.move : 0; //初始化移动位置
    // 设置bar

    that.bar = document.createElement('div');
    that.bar.className = 'dui-scrollbar__bar' + ' is-' + that.config.key; // 设置thumb

    that.thumb = document.createElement('div');
    that.thumb.className = 'dui-scrollbar__thumb'; // 设置thumb的styl

    that.thumb.style = renderThumbStyle({
      move: move,
      size: size,
      bar: bar
    }); // 添加元素

    that.bar.append(that.thumb);
    parent.scroll.append(that.bar); // 设置事件

    on(that.bar, 'mousedown', function (e) {
      // console.log();
      var offset = Math.abs(e.target.getBoundingClientRect()[bar.direction] - e[bar.client]);
      var thumbHalf = that.thumb[bar.offset] / 2;
      var thumbPositionPercentage = (offset - thumbHalf) * 100 / that.bar[bar.offset];
      parent.wrap[bar.scroll] = thumbPositionPercentage * parent.wrap[bar.scrollSize] / 100;
    }); // 设置滚动条被点击

    on(that.thumb, 'mousedown', function (e) {
      // 防止右键点击
      if (e.ctrlKey || e.button === 2) {
        return;
      }

      startDrag(e);
      that[bar.axis] = e.currentTarget[bar.offset] - (e[bar.client] - e.currentTarget.getBoundingClientRect()[bar.direction]);
    });

    function startDrag(e) {
      e.stopImmediatePropagation();
      that.cursorDown = true;
      on(document, 'mousemove', mouseMoveDocumentHandler);
      on(document, 'mouseup', mouseUpDocumentHandler);

      document.onselectstart = function () {
        return false;
      };
    }

    function mouseMoveDocumentHandler(e) {
      if (that.cursorDown === false) return;
      var prevPage = that[bar.axis];
      if (!prevPage) return;
      var offset = (that.bar.getBoundingClientRect()[bar.direction] - e[bar.client]) * -1;
      var thumbClickPosition = that.thumb[bar.offset] - prevPage;
      var thumbPositionPercentage = (offset - thumbClickPosition) * 100 / that.bar[bar.offset];
      parent.wrap[bar.scroll] = thumbPositionPercentage * parent.wrap[bar.scrollSize] / 100;
    }

    function mouseUpDocumentHandler(e) {
      that.cursorDown = false;
      that[bar.axis] = 0;
      off(document, 'mousemove', mouseMoveDocumentHandler);
      document.onselectstart = null;
    }
  }
  function renderThumbStyle(_ref) {
    var move = _ref.move,
        size = _ref.size,
        bar = _ref.bar;
    var style = {};
    var returns = '';
    var translate = "translate".concat(bar.axis, "(").concat(move, "%)");
    style[bar.size] = size;
    style.transform = translate;
    each(style, function (key, value) {
      returns += key + ':' + value + ';';
    });
    return returns;
  }
  function addScrollBar (el, options) {
    return new scrollbar(el, options);
  }

  function sort (obj, key, desc) {
    var clone = JSON.parse(JSON.stringify(obj || []));
    if (!key) return clone; //如果是数字，按大小排序，如果是非数字，按字典序排序

    clone.sort(function (o1, o2) {
      var isNum = /^-?\d+$/,
          v1 = o1[key],
          v2 = o2[key];
      if (isNum.test(v1)) v1 = parseFloat(v1);
      if (isNum.test(v2)) v2 = parseFloat(v2);

      if (v1 && !v2) {
        return 1;
      } else if (!v1 && v2) {
        return -1;
      }

      if (v1 > v2) {
        return 1;
      } else if (v1 < v2) {
        return -1;
      } else {
        return 0;
      }
    });
    desc && clone.reverse(); //倒序

    return clone;
  }

  /**
   * 初始化js类
   * @param {Object} options jsTree配置如：{
   * id:"id",
   * pid:"pid",
   * child:"child"
   * }
   */
  var JsTree = function JsTree(options) {
    var that = this;
    that.config = dui.extend(true, {
      id: "id",
      // id名称
      pid: "pid",
      // pid名称
      child: "child" // 子元素键名

    }, options);
    return that;
  };
  /**
   * 获取带层级的数据
   * @param {Array} lists 数据集
   * @param {String} pid 父节点编号
   * @param {number} level 当前层级别
   */


  JsTree.prototype.toLayer = function (lists, pid, level) {
    var that = this,
        config = that.config,
        trees = [],
        clone = JSON.parse(JSON.stringify(lists));
    pid = pid ? pid : 0, level = level ? level : 0;
    dui.each(clone, function (key, value) {
      if (value[config.pid] == pid) {
        var child = that.toLayer(clone, value[config.id], level + 1);

        if (child.length > 0) {
          value['hasChild'] = true;
          value[config.child] = child;
        }

        trees.push(value);
      }
    });
    return trees;
  };

  JsTree.prototype.toList = function (lists, pid, level) {
    var that = this,
        config = that.config,
        trees = [],
        clone = JSON.parse(JSON.stringify(lists));
    pid = pid ? pid : 0, level = level ? level : 0;
    dui.each(clone, function (key, value) {
      var temp = JSON.parse(JSON.stringify(clone));

      if (value[config.pid] == pid) {
        value['level'] = level + 1;
        var child = that.toLayer(temp, value[config.id], level + 1);

        if (child.length > 0) {
          //表示有子节点
          value['hasChild'] = true;
          value[config.child] = child;
        }

        trees.push(value);
        trees = trees.concat(that.toList(clone, value[config.id], level + 1));
      }
    });
    return trees;
  };

  Dui.extend({
    trim: trim,
    //去空
    on: on,
    //给元素添加事件
    off: off,
    //给元素关闭事件
    once: once,
    //只运行一次的函数
    getStyle: getStyle,
    //获取元素的样式
    setStyle: setStyle,
    //设置样式
    scrollBarWidth: scrollBarWidth,
    //获取当前浏览器滚动条的宽度
    hasClass: hasClass,
    //判断该元素是否有该class
    addClass: addClass,
    //给元素添加class
    removeClass: removeClass,
    //给元素移除class
    transition: transition,
    //过渡组件
    collapseTransition: collapseTransition,
    //高度变化过渡组件
    watcher: watcher,
    //监听属性变化
    setVnode: setVnode,
    //给元素设置一个模拟属性
    setData: setData,
    //给元素设置一些数据
    bind: bind,
    //在组件化的事件管理器里添加事件
    unbind: unbind,
    //在组件化的事件管理器里移除事件
    setProps: setProps,
    //设置元素的prop属性，只在vnode里面展示
    convertProp: convertProp,
    //转换现有的元素的prop属性
    getMaxZIndex: getMaxZIndex,
    //获取元素最大的z-index
    addPopper: addPopper,
    //给元素添加弹出层
    addScrollBar: addScrollBar,
    //给元素添加内置的滚动条
    addResizeListener: addResizeListener,
    //添加监听元素发生变化事件
    removeResizeListener: removeResizeListener,
    //移除监听元素发生变化事件
    sort: sort,
    //排序方法
    jsTree: JsTree //前端数组转tree库

  });

  return Dui;

}));
